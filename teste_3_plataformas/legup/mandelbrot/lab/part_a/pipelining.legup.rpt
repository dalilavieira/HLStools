//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 3.0 (http://legup.org)
// Compiled: Tue Jul 15 15:43:09 2014
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Fri Feb 14 11:38:14 2020
//----------------------------------------------------------------------------//

Found Loop: Loop at depth 3 containing: %10<header><latch><exiting>

Label: loop
Trip count: 50
Induction variable:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ]
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Loop preheader: 
--------------------------------------------------------------------------------

Calculating resource MII using IMS technique
Overall resMII: 1
largestPossibleII: 28
resMII: 1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Finding all Loop Recurrences
Found 5 elementary recurrence cycles
Recurrence 1:
delay: 1 I:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
delay: 1 I:   %28 = add nsw i32 %27, %fiter.04.i
delay: 1 I:   %phitmp.i = and i32 %28, 255
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 2:
delay: 1 I:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
delay: 1 I:   %29 = add i8 %iter.03.i, 1
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 3:
delay: 1 I:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
delay: 1 I:   %11 = sext i32 %x.02.i to i64
delay: 2 I:   %12 = mul nsw i64 %11, %11
delay: 2 I:   %13 = ashr i64 %12, 28
delay: 2 I:   %18 = add i64 %13, %9
delay: 2 I:   %19 = sub i64 %18, %16
delay: 2 I:   %20 = trunc i64 %19 to i32
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Recurrence 4:
delay: 1 I:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
delay: 1 I:   %11 = sext i32 %x.02.i to i64
delay: 2 I:   %21 = mul nsw i64 %14, %11
delay: 2 I:   %22 = lshr i64 %21, 27
delay: 2 I:   %23 = and i64 %22, 4294967294
delay: 2 I:   %24 = add nsw i64 %23, %4
delay: 2 I:   %25 = trunc i64 %24 to i32
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
delay: 3 I:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
delay: 3 I:   %14 = sext i32 %y.01.i to i64
delay: 4 I:   %15 = mul nsw i64 %14, %14
delay: 4 I:   %16 = ashr i64 %15, 28
delay: 4 I:   %19 = sub i64 %18, %16
delay: 4 I:   %20 = trunc i64 %19 to i32
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
More than one back edge -- ignoring
Recurrence 5:
delay: 1 I:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
delay: 1 I:   %14 = sext i32 %y.01.i to i64
delay: 2 I:   %21 = mul nsw i64 %14, %11
delay: 2 I:   %22 = lshr i64 %21, 27
delay: 2 I:   %23 = and i64 %22, 4294967294
delay: 2 I:   %24 = add nsw i64 %23, %4
delay: 2 I:   %25 = trunc i64 %24 to i32
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Overall recMII (max of recMII from all elementary recurrence cycles): 2
--------------------------------------------------------------------------------
Calculating recurrence MII using SDC scheduler
Trying recMII (SDC) = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = trunc i64 %19 to i32
	j:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %25 = trunc i64 %24 to i32
	j:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %29 = add i8 %iter.03.i, 1
	j:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %phitmp.i = and i32 %28, 255
	j:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
recMII = 2 using SDC scheduler
--------------------------------------------------------------------------------
Initial II = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = trunc i64 %19 to i32
	j:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %25 = trunc i64 %24 to i32
	j:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %29 = add i8 %iter.03.i, 1
	j:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %phitmp.i = and i32 %28, 255
	j:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Computing Heights
No children (height=0):   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str, i32 0, i32 0)) nounwind
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
No children (height=0):   ret i32 %32
No children (height=0):   br i1 %37, label %38, label %40
No children (height=0):   %36 = tail call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([11 x i8]* @.str1, i32 0, i32 0), i32 %32) nounwind
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
No children (height=0):   br i1 %exitcond, label %30, label %10
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
--------------------------------------------------------------------------------
Height: 0:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Height: 0:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Height: 0:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Height: 0:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Height: 0:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str, i32 0, i32 0)) nounwind
Height: 1:   %11 = sext i32 %x.02.i to i64
Height: 1:   %12 = mul nsw i64 %11, %11
Height: 0:   %13 = ashr i64 %12, 28
Height: 1:   %14 = sext i32 %y.01.i to i64
Height: 1:   %15 = mul nsw i64 %14, %14
Height: 0:   %16 = ashr i64 %15, 28
Height: 0:   %17 = add nsw i64 %16, %13
Height: 0:   %18 = add i64 %13, %9
Height: 0:   %19 = sub i64 %18, %16
Height: 0:   %20 = trunc i64 %19 to i32
Height: 1:   %21 = mul nsw i64 %14, %11
Height: 0:   %22 = lshr i64 %21, 27
Height: 0:   %23 = and i64 %22, 4294967294
Height: 0:   %24 = add nsw i64 %23, %4
Height: 0:   %25 = trunc i64 %24 to i32
Height: 0:   %26 = icmp slt i64 %17, 1073741825
Height: 0:   %27 = zext i1 %26 to i32
Height: 0:   %28 = add nsw i32 %27, %fiter.04.i
Height: 0:   %29 = add i8 %iter.03.i, 1
Height: 0:   %phitmp.i = and i32 %28, 255
Height: 0:   %exitcond = icmp eq i8 %29, 50
Height: 0:   br i1 %exitcond, label %30, label %10
Modulo Scheduler Type: SDC_BACKTRACKING
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %20 = trunc i64 %19 to i32 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = trunc i64 %19 to i32
	j:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
distance 1 from:   %25 = trunc i64 %24 to i32 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %25 = trunc i64 %24 to i32
	j:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
distance 1 from:   %29 = add i8 %iter.03.i, 1 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %29 = add i8 %iter.03.i, 1
	j:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
distance 1 from:   %phitmp.i = and i32 %28, 255 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %phitmp.i = and i32 %28, 255
	j:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Finding initial ASAP schedule
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Calculating perturbation priority function
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Assigning timeslot: 0 to   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Assigning timeslot: 0 to   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !0
Assigning timeslot: 0 to   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Assigning timeslot: 0 to   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Assigning timeslot: 0 to   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str, i32 0, i32 0)) nounwind
Assigning timeslot: 0 to   %11 = sext i32 %x.02.i to i64
Assigning timeslot: 0 to   %12 = mul nsw i64 %11, %11
Assigning timeslot: 1 to   %13 = ashr i64 %12, 28
Assigning timeslot: 0 to   %14 = sext i32 %y.01.i to i64
Assigning timeslot: 0 to   %15 = mul nsw i64 %14, %14
Assigning timeslot: 1 to   %16 = ashr i64 %15, 28
Assigning timeslot: 1 to   %17 = add nsw i64 %16, %13
Assigning timeslot: 1 to   %18 = add i64 %13, %9
Assigning timeslot: 1 to   %19 = sub i64 %18, %16
Assigning timeslot: 1 to   %20 = trunc i64 %19 to i32
Assigning timeslot: 0 to   %21 = mul nsw i64 %14, %11
Assigning timeslot: 1 to   %22 = lshr i64 %21, 27
Assigning timeslot: 1 to   %23 = and i64 %22, 4294967294
Assigning timeslot: 1 to   %24 = add nsw i64 %23, %4
Assigning timeslot: 1 to   %25 = trunc i64 %24 to i32
Assigning timeslot: 2 to   %26 = icmp slt i64 %17, 1073741825
Assigning timeslot: 2 to   %27 = zext i1 %26 to i32
Assigning timeslot: 2 to   %28 = add nsw i32 %27, %fiter.04.i
Assigning timeslot: 0 to   %29 = add i8 %iter.03.i, 1
Assigning timeslot: 2 to   %phitmp.i = and i32 %28, 255
Assigning timeslot: 0 to   %exitcond = icmp eq i8 %29, 50
Assigning timeslot: 0 to   br i1 %exitcond, label %30, label %10
Scheduled.
MII = 2
II = 2
Final Modulo Reservation Table:

Final Pipeline Schedule:
Total pipeline stages: 2
Stage: 0
Time: 0 Stage: 0 instr:   %fiter.04.i = phi i32 [ 0, %5 ], [ %phitmp.i, %10 ]
Time: 0 Stage: 0 instr:   %iter.03.i = phi i8 [ 0, %5 ], [ %29, %10 ], !legup.canonical_induction !1
Time: 0 Stage: 0 instr:   %x.02.i = phi i32 [ 0, %5 ], [ %20, %10 ]
Time: 0 Stage: 0 instr:   %y.01.i = phi i32 [ 0, %5 ], [ %25, %10 ]
Time: 0 Stage: 0 instr:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str, i32 0, i32 0)) nounwind
Time: 0 Stage: 0 instr:   %11 = sext i32 %x.02.i to i64
Time: 0 Stage: 0 instr:   %12 = mul nsw i64 %11, %11
Time: 0 Stage: 0 instr:   %14 = sext i32 %y.01.i to i64
Time: 0 Stage: 0 instr:   %15 = mul nsw i64 %14, %14
Time: 0 Stage: 0 instr:   %21 = mul nsw i64 %14, %11
Time: 0 Stage: 0 instr:   %29 = add i8 %iter.03.i, 1
Time: 0 Stage: 0 instr:   %exitcond = icmp eq i8 %29, 50
Time: 0 Stage: 0 instr:   br i1 %exitcond, label %30, label %10
Time: 1 Stage: 0 instr:   %13 = ashr i64 %12, 28
Time: 1 Stage: 0 instr:   %16 = ashr i64 %15, 28
Time: 1 Stage: 0 instr:   %17 = add nsw i64 %16, %13
Time: 1 Stage: 0 instr:   %18 = add i64 %13, %9
Time: 1 Stage: 0 instr:   %19 = sub i64 %18, %16
Time: 1 Stage: 0 instr:   %20 = trunc i64 %19 to i32
Time: 1 Stage: 0 instr:   %22 = lshr i64 %21, 27
Time: 1 Stage: 0 instr:   %23 = and i64 %22, 4294967294
Time: 1 Stage: 0 instr:   %24 = add nsw i64 %23, %4
Time: 1 Stage: 0 instr:   %25 = trunc i64 %24 to i32
Stage: 1
Time: 2 Stage: 1 instr:   %26 = icmp slt i64 %17, 1073741825
Time: 2 Stage: 1 instr:   %27 = zext i1 %26 to i32
Time: 2 Stage: 1 instr:   %28 = add nsw i32 %27, %fiter.04.i
Time: 2 Stage: 1 instr:   %phitmp.i = and i32 %28, 255


Pipeline Table:
Total pipeline stages: 2
Stage:               0                             1
   II:        0              1     |        0              1
 Time:        0              1     |        2              3
    %fiter.04.i              -    %fiter.04.i              -
     %iter.03.i              -     %iter.03.i              -
        %x.02.i              -        %x.02.i              -
        %y.01.i              -        %y.01.i              -
       <badref>              -       <badref>              -
            %11              -            %11              -
            %12              -            %12              -
              -            %13              -            %13
            %14              -            %14              -
            %15              -            %15              -
              -            %16              -            %16
              -            %17              -            %17
              -            %18              -            %18
              -            %19              -            %19
              -            %20              -            %20
            %21              -            %21              -
              -            %22              -            %22
              -            %23              -            %23
              -            %24              -            %24
              -            %25              -            %25
              -              -            %26              -
              -              -            %27              -
              -              -            %28              -
            %29              -            %29              -
              -              -      %phitmp.i              -
      %exitcond              -      %exitcond              -
       <badref>              -       <badref>              -

