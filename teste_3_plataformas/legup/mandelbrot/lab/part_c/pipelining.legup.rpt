//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 3.0 (http://legup.org)
// Compiled: Tue Jul 15 15:43:09 2014
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Thu Feb 13 11:08:49 2020
//----------------------------------------------------------------------------//

Found Loop: Loop at depth 3 containing: %bb2<header><latch><exiting>

Label: loop
Trip count: 50
Induction variable:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ]
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Loop preheader: bb1
--------------------------------------------------------------------------------

Calculating resource MII using IMS technique
Overall resMII: 1
largestPossibleII: 30
resMII: 1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Finding all Loop Recurrences
Found 5 elementary recurrence cycles
Recurrence 1:
delay: 1 I:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
delay: 1 I:   %18 = add i8 %17, %fiter.013
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 2:
delay: 1 I:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
delay: 1 I:   %19 = add i8 %iter.012, 1
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 3:
delay: 1 I:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
delay: 1 I:   %9 = sext i32 %y.011 to i64
delay: 2 I:   %10 = mul nsw i64 %9, %9
delay: 2 I:   %tmp29 = lshr i64 %10, 28
delay: 2 I:   %tmp30 = trunc i64 %tmp29 to i32
delay: 2 I:   %tmp31 = sub i32 %tmp26, %tmp30
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
delay: 3 I:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
delay: 3 I:   %6 = sext i32 %x.010 to i64
delay: 4 I:   %13 = mul nsw i64 %9, %6
delay: 4 I:   %14 = lshr i64 %13, 27
delay: 4 I:   %.tr = trunc i64 %14 to i32
delay: 4 I:   %15 = and i32 %.tr, -2
delay: 4 I:   %tmp40 = add i32 %tmp39, %15
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
More than one back edge -- ignoring
Recurrence 4:
delay: 1 I:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
delay: 1 I:   %9 = sext i32 %y.011 to i64
delay: 2 I:   %13 = mul nsw i64 %9, %6
delay: 2 I:   %14 = lshr i64 %13, 27
delay: 2 I:   %.tr = trunc i64 %14 to i32
delay: 2 I:   %15 = and i32 %.tr, -2
delay: 2 I:   %tmp40 = add i32 %tmp39, %15
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Recurrence 5:
delay: 1 I:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
delay: 1 I:   %6 = sext i32 %x.010 to i64
delay: 2 I:   %7 = mul nsw i64 %6, %6
delay: 2 I:   %tmp24 = lshr i64 %7, 28
delay: 2 I:   %tmp25 = trunc i64 %tmp24 to i32
delay: 2 I:   %tmp26 = add i32 %tmp21, %tmp25
delay: 2 I:   %tmp31 = sub i32 %tmp26, %tmp30
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Overall recMII (max of recMII from all elementary recurrence cycles): 2
--------------------------------------------------------------------------------
Calculating recurrence MII using SDC scheduler
Trying recMII (SDC) = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %18 = add i8 %17, %fiter.013
	j:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %iter.012, 1
	j:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31 = sub i32 %tmp26, %tmp30
	j:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40 = add i32 %tmp39, %15
	j:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
recMII = 2 using SDC scheduler
--------------------------------------------------------------------------------
Initial II = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %18 = add i8 %17, %fiter.013
	j:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %iter.012, 1
	j:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31 = sub i32 %tmp26, %tmp30
	j:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40 = add i32 %tmp39, %15
	j:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Computing Heights
No children (height=0):   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
No children (height=0):   volatile store i8 %21, i8* %scevgep, align 1
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
No children (height=0):   br i1 %exitcond, label %bb4, label %bb2
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
--------------------------------------------------------------------------------
Height: 0:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Height: 0:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Height: 0:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Height: 0:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Height: 0:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Height: 1:   %6 = sext i32 %x.010 to i64
Height: 1:   %7 = mul nsw i64 %6, %6
Height: 0:   %8 = ashr i64 %7, 28
Height: 1:   %9 = sext i32 %y.011 to i64
Height: 1:   %10 = mul nsw i64 %9, %9
Height: 0:   %11 = ashr i64 %10, 28
Height: 0:   %12 = add nsw i64 %11, %8
Height: 1:   %13 = mul nsw i64 %9, %6
Height: 0:   %14 = lshr i64 %13, 27
Height: 0:   %.tr = trunc i64 %14 to i32
Height: 0:   %15 = and i32 %.tr, -2
Height: 0:   %16 = icmp slt i64 %12, 1073741825
Height: 0:   %17 = zext i1 %16 to i8
Height: 0:   %18 = add i8 %17, %fiter.013
Height: 0:   %19 = add i8 %iter.012, 1
Height: 0:   %exitcond = icmp eq i8 %19, 50
Height: 0:   %tmp24 = lshr i64 %7, 28
Height: 0:   %tmp25 = trunc i64 %tmp24 to i32
Height: 0:   %tmp26 = add i32 %tmp21, %tmp25
Height: 0:   %tmp29 = lshr i64 %10, 28
Height: 0:   %tmp30 = trunc i64 %tmp29 to i32
Height: 0:   %tmp31 = sub i32 %tmp26, %tmp30
Height: 0:   %tmp40 = add i32 %tmp39, %15
Height: 0:   br i1 %exitcond, label %bb4, label %bb2
Modulo Scheduler Type: SDC_BACKTRACKING
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %18 = add i8 %17, %fiter.013 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %18 = add i8 %17, %fiter.013
	j:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
distance 1 from:   %19 = add i8 %iter.012, 1 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %iter.012, 1
	j:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
distance 1 from:   %tmp31 = sub i32 %tmp26, %tmp30 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31 = sub i32 %tmp26, %tmp30
	j:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
distance 1 from:   %tmp40 = add i32 %tmp39, %15 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40 = add i32 %tmp39, %15
	j:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Finding initial ASAP schedule
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Calculating perturbation priority function
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Assigning timeslot: 1 to   %tmp31 = sub i32 %tmp26, %tmp30
Assigning timeslot: 1 to   %tmp40 = add i32 %tmp39, %15
Assigning timeslot: 0 to   br i1 %exitcond, label %bb4, label %bb2
Assigning timeslot: 0 to   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Assigning timeslot: 0 to   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !0
Assigning timeslot: 0 to   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Assigning timeslot: 0 to   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Assigning timeslot: 0 to   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Assigning timeslot: 0 to   %6 = sext i32 %x.010 to i64
Assigning timeslot: 0 to   %7 = mul nsw i64 %6, %6
Assigning timeslot: 1 to   %8 = ashr i64 %7, 28
Assigning timeslot: 0 to   %9 = sext i32 %y.011 to i64
Assigning timeslot: 0 to   %10 = mul nsw i64 %9, %9
Assigning timeslot: 1 to   %11 = ashr i64 %10, 28
Assigning timeslot: 1 to   %12 = add nsw i64 %11, %8
Assigning timeslot: 0 to   %13 = mul nsw i64 %9, %6
Assigning timeslot: 1 to   %14 = lshr i64 %13, 27
Assigning timeslot: 1 to   %.tr = trunc i64 %14 to i32
Assigning timeslot: 1 to   %15 = and i32 %.tr, -2
Assigning timeslot: 2 to   %16 = icmp slt i64 %12, 1073741825
Assigning timeslot: 2 to   %17 = zext i1 %16 to i8
Assigning timeslot: 2 to   %18 = add i8 %17, %fiter.013
Assigning timeslot: 0 to   %19 = add i8 %iter.012, 1
Assigning timeslot: 0 to   %exitcond = icmp eq i8 %19, 50
Assigning timeslot: 1 to   %tmp24 = lshr i64 %7, 28
Assigning timeslot: 1 to   %tmp25 = trunc i64 %tmp24 to i32
Assigning timeslot: 1 to   %tmp26 = add i32 %tmp21, %tmp25
Assigning timeslot: 1 to   %tmp29 = lshr i64 %10, 28
Assigning timeslot: 1 to   %tmp30 = trunc i64 %tmp29 to i32
Scheduled.
MII = 2
II = 2
Final Modulo Reservation Table:

Final Pipeline Schedule:
Total pipeline stages: 2
Stage: 0
Time: 0 Stage: 0 instr:   %fiter.013 = phi i8 [ 0, %bb1 ], [ %18, %bb2 ]
Time: 0 Stage: 0 instr:   %iter.012 = phi i8 [ 0, %bb1 ], [ %19, %bb2 ], !legup.canonical_induction !1
Time: 0 Stage: 0 instr:   %y.011 = phi i32 [ 0, %bb1 ], [ %tmp40, %bb2 ]
Time: 0 Stage: 0 instr:   %x.010 = phi i32 [ 0, %bb1 ], [ %tmp31, %bb2 ]
Time: 0 Stage: 0 instr:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Time: 0 Stage: 0 instr:   %6 = sext i32 %x.010 to i64
Time: 0 Stage: 0 instr:   %7 = mul nsw i64 %6, %6
Time: 0 Stage: 0 instr:   %9 = sext i32 %y.011 to i64
Time: 0 Stage: 0 instr:   %10 = mul nsw i64 %9, %9
Time: 0 Stage: 0 instr:   %13 = mul nsw i64 %9, %6
Time: 0 Stage: 0 instr:   %19 = add i8 %iter.012, 1
Time: 0 Stage: 0 instr:   %exitcond = icmp eq i8 %19, 50
Time: 0 Stage: 0 instr:   br i1 %exitcond, label %bb4, label %bb2
Time: 1 Stage: 0 instr:   %8 = ashr i64 %7, 28
Time: 1 Stage: 0 instr:   %11 = ashr i64 %10, 28
Time: 1 Stage: 0 instr:   %12 = add nsw i64 %11, %8
Time: 1 Stage: 0 instr:   %14 = lshr i64 %13, 27
Time: 1 Stage: 0 instr:   %.tr = trunc i64 %14 to i32
Time: 1 Stage: 0 instr:   %15 = and i32 %.tr, -2
Time: 1 Stage: 0 instr:   %tmp24 = lshr i64 %7, 28
Time: 1 Stage: 0 instr:   %tmp25 = trunc i64 %tmp24 to i32
Time: 1 Stage: 0 instr:   %tmp26 = add i32 %tmp21, %tmp25
Time: 1 Stage: 0 instr:   %tmp29 = lshr i64 %10, 28
Time: 1 Stage: 0 instr:   %tmp30 = trunc i64 %tmp29 to i32
Time: 1 Stage: 0 instr:   %tmp31 = sub i32 %tmp26, %tmp30
Time: 1 Stage: 0 instr:   %tmp40 = add i32 %tmp39, %15
Stage: 1
Time: 2 Stage: 1 instr:   %16 = icmp slt i64 %12, 1073741825
Time: 2 Stage: 1 instr:   %17 = zext i1 %16 to i8
Time: 2 Stage: 1 instr:   %18 = add i8 %17, %fiter.013


Pipeline Table:
Total pipeline stages: 2
Stage:               0                             1
   II:        0              1     |        0              1
 Time:        0              1     |        2              3
     %fiter.013              -     %fiter.013              -
      %iter.012              -      %iter.012              -
         %y.011              -         %y.011              -
         %x.010              -         %x.010              -
       <badref>              -       <badref>              -
             %6              -             %6              -
             %7              -             %7              -
              -             %8              -             %8
             %9              -             %9              -
            %10              -            %10              -
              -            %11              -            %11
              -            %12              -            %12
            %13              -            %13              -
              -            %14              -            %14
              -           %.tr              -           %.tr
              -            %15              -            %15
              -              -            %16              -
              -              -            %17              -
              -              -            %18              -
            %19              -            %19              -
      %exitcond              -      %exitcond              -
              -         %tmp24              -         %tmp24
              -         %tmp25              -         %tmp25
              -         %tmp26              -         %tmp26
              -         %tmp29              -         %tmp29
              -         %tmp30              -         %tmp30
              -         %tmp31              -         %tmp31
              -         %tmp40              -         %tmp40
       <badref>              -       <badref>              -

Found Loop: Loop at depth 3 containing: %bb2.i<header><latch><exiting>

Label: loop
Trip count: 50
Induction variable:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ]
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Loop preheader: bb1.i
--------------------------------------------------------------------------------

Calculating resource MII using IMS technique
Overall resMII: 1
largestPossibleII: 30
resMII: 1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Finding all Loop Recurrences
Found 5 elementary recurrence cycles
Recurrence 1:
delay: 1 I:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
delay: 1 I:   %19 = add i8 %18, %fiter.013.i
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 2:
delay: 1 I:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
delay: 1 I:   %20 = add i8 %iter.012.i, 1
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 3:
delay: 1 I:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
delay: 1 I:   %10 = sext i32 %y.011.i to i64
delay: 2 I:   %11 = mul nsw i64 %10, %10
delay: 2 I:   %tmp29.i = lshr i64 %11, 28
delay: 2 I:   %tmp30.i = trunc i64 %tmp29.i to i32
delay: 2 I:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
delay: 3 I:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
delay: 3 I:   %7 = sext i32 %x.010.i to i64
delay: 4 I:   %14 = mul nsw i64 %10, %7
delay: 4 I:   %15 = lshr i64 %14, 27
delay: 4 I:   %.tr.i = trunc i64 %15 to i32
delay: 4 I:   %16 = and i32 %.tr.i, -2
delay: 4 I:   %tmp40.i = add i32 %tmp39.i, %16
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
More than one back edge -- ignoring
Recurrence 4:
delay: 1 I:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
delay: 1 I:   %10 = sext i32 %y.011.i to i64
delay: 2 I:   %14 = mul nsw i64 %10, %7
delay: 2 I:   %15 = lshr i64 %14, 27
delay: 2 I:   %.tr.i = trunc i64 %15 to i32
delay: 2 I:   %16 = and i32 %.tr.i, -2
delay: 2 I:   %tmp40.i = add i32 %tmp39.i, %16
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Recurrence 5:
delay: 1 I:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
delay: 1 I:   %7 = sext i32 %x.010.i to i64
delay: 2 I:   %8 = mul nsw i64 %7, %7
delay: 2 I:   %tmp24.i = lshr i64 %8, 28
delay: 2 I:   %tmp25.i = trunc i64 %tmp24.i to i32
delay: 2 I:   %tmp26.i = add i32 %tmp21.i, %tmp25.i
delay: 2 I:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Total cycle delay: 2
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 2

Overall recMII (max of recMII from all elementary recurrence cycles): 2
--------------------------------------------------------------------------------
Calculating recurrence MII using SDC scheduler
Trying recMII (SDC) = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %18, %fiter.013.i
	j:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = add i8 %iter.012.i, 1
	j:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
	j:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40.i = add i32 %tmp39.i, %16
	j:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
recMII = 2 using SDC scheduler
--------------------------------------------------------------------------------
Initial II = 2
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %18, %fiter.013.i
	j:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = add i8 %iter.012.i, 1
	j:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
	j:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40.i = add i32 %tmp39.i, %16
	j:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Computing Heights
No children (height=0):   call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
No children (height=0):   volatile store i8 %22, i8* %scevgep.i, align 1
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
No children (height=0):   br i1 %exitcond.i, label %bb4.i, label %bb2.i
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
--------------------------------------------------------------------------------
Height: 0:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Height: 0:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Height: 0:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Height: 0:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Height: 0:   call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Height: 1:   %7 = sext i32 %x.010.i to i64
Height: 1:   %8 = mul nsw i64 %7, %7
Height: 0:   %9 = ashr i64 %8, 28
Height: 1:   %10 = sext i32 %y.011.i to i64
Height: 1:   %11 = mul nsw i64 %10, %10
Height: 0:   %12 = ashr i64 %11, 28
Height: 0:   %13 = add nsw i64 %12, %9
Height: 1:   %14 = mul nsw i64 %10, %7
Height: 0:   %15 = lshr i64 %14, 27
Height: 0:   %.tr.i = trunc i64 %15 to i32
Height: 0:   %16 = and i32 %.tr.i, -2
Height: 0:   %17 = icmp slt i64 %13, 1073741825
Height: 0:   %18 = zext i1 %17 to i8
Height: 0:   %19 = add i8 %18, %fiter.013.i
Height: 0:   %20 = add i8 %iter.012.i, 1
Height: 0:   %exitcond.i = icmp eq i8 %20, 50
Height: 0:   %tmp24.i = lshr i64 %8, 28
Height: 0:   %tmp25.i = trunc i64 %tmp24.i to i32
Height: 0:   %tmp26.i = add i32 %tmp21.i, %tmp25.i
Height: 0:   %tmp29.i = lshr i64 %11, 28
Height: 0:   %tmp30.i = trunc i64 %tmp29.i to i32
Height: 0:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
Height: 0:   %tmp40.i = add i32 %tmp39.i, %16
Height: 0:   br i1 %exitcond.i, label %bb4.i, label %bb2.i
Modulo Scheduler Type: SDC_BACKTRACKING
--------------------------------------------------------------------------------
initializing SDC constraints for II = 2
distance 1 from:   %19 = add i8 %18, %fiter.013.i to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %19 = add i8 %18, %fiter.013.i
	j:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
distance 1 from:   %20 = add i8 %iter.012.i, 1 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %20 = add i8 %iter.012.i, 1
	j:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
distance 1 from:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
	j:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
distance 1 from:   %tmp40.i = add i32 %tmp39.i, %16 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 2 distance: 1
	i:   %tmp40.i = add i32 %tmp39.i, %16
	j:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Finding initial ASAP schedule
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Calculating perturbation priority function
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Assigning timeslot: 0 to   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Assigning timeslot: 0 to   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Assigning timeslot: 0 to   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Assigning timeslot: 0 to   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Assigning timeslot: 0 to   call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Assigning timeslot: 0 to   %7 = sext i32 %x.010.i to i64
Assigning timeslot: 0 to   %8 = mul nsw i64 %7, %7
Assigning timeslot: 1 to   %9 = ashr i64 %8, 28
Assigning timeslot: 0 to   %10 = sext i32 %y.011.i to i64
Assigning timeslot: 0 to   %11 = mul nsw i64 %10, %10
Assigning timeslot: 1 to   %12 = ashr i64 %11, 28
Assigning timeslot: 1 to   %13 = add nsw i64 %12, %9
Assigning timeslot: 0 to   %14 = mul nsw i64 %10, %7
Assigning timeslot: 1 to   %15 = lshr i64 %14, 27
Assigning timeslot: 1 to   %.tr.i = trunc i64 %15 to i32
Assigning timeslot: 1 to   %16 = and i32 %.tr.i, -2
Assigning timeslot: 2 to   %17 = icmp slt i64 %13, 1073741825
Assigning timeslot: 2 to   %18 = zext i1 %17 to i8
Assigning timeslot: 2 to   %19 = add i8 %18, %fiter.013.i
Assigning timeslot: 0 to   %20 = add i8 %iter.012.i, 1
Assigning timeslot: 0 to   %exitcond.i = icmp eq i8 %20, 50
Assigning timeslot: 1 to   %tmp24.i = lshr i64 %8, 28
Assigning timeslot: 1 to   %tmp25.i = trunc i64 %tmp24.i to i32
Assigning timeslot: 1 to   %tmp26.i = add i32 %tmp21.i, %tmp25.i
Assigning timeslot: 1 to   %tmp29.i = lshr i64 %11, 28
Assigning timeslot: 1 to   %tmp30.i = trunc i64 %tmp29.i to i32
Assigning timeslot: 1 to   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
Assigning timeslot: 1 to   %tmp40.i = add i32 %tmp39.i, %16
Assigning timeslot: 0 to   br i1 %exitcond.i, label %bb4.i, label %bb2.i
Scheduled.
MII = 2
II = 2
Final Modulo Reservation Table:

Final Pipeline Schedule:
Total pipeline stages: 2
Stage: 0
Time: 0 Stage: 0 instr:   %fiter.013.i = phi i8 [ 0, %bb1.i ], [ %19, %bb2.i ]
Time: 0 Stage: 0 instr:   %iter.012.i = phi i8 [ 0, %bb1.i ], [ %20, %bb2.i ], !legup.canonical_induction !1
Time: 0 Stage: 0 instr:   %y.011.i = phi i32 [ 0, %bb1.i ], [ %tmp40.i, %bb2.i ]
Time: 0 Stage: 0 instr:   %x.010.i = phi i32 [ 0, %bb1.i ], [ %tmp31.i, %bb2.i ]
Time: 0 Stage: 0 instr:   call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str3, i32 0, i32 0)) nounwind
Time: 0 Stage: 0 instr:   %7 = sext i32 %x.010.i to i64
Time: 0 Stage: 0 instr:   %8 = mul nsw i64 %7, %7
Time: 0 Stage: 0 instr:   %10 = sext i32 %y.011.i to i64
Time: 0 Stage: 0 instr:   %11 = mul nsw i64 %10, %10
Time: 0 Stage: 0 instr:   %14 = mul nsw i64 %10, %7
Time: 0 Stage: 0 instr:   %20 = add i8 %iter.012.i, 1
Time: 0 Stage: 0 instr:   %exitcond.i = icmp eq i8 %20, 50
Time: 0 Stage: 0 instr:   br i1 %exitcond.i, label %bb4.i, label %bb2.i
Time: 1 Stage: 0 instr:   %9 = ashr i64 %8, 28
Time: 1 Stage: 0 instr:   %12 = ashr i64 %11, 28
Time: 1 Stage: 0 instr:   %13 = add nsw i64 %12, %9
Time: 1 Stage: 0 instr:   %15 = lshr i64 %14, 27
Time: 1 Stage: 0 instr:   %.tr.i = trunc i64 %15 to i32
Time: 1 Stage: 0 instr:   %16 = and i32 %.tr.i, -2
Time: 1 Stage: 0 instr:   %tmp24.i = lshr i64 %8, 28
Time: 1 Stage: 0 instr:   %tmp25.i = trunc i64 %tmp24.i to i32
Time: 1 Stage: 0 instr:   %tmp26.i = add i32 %tmp21.i, %tmp25.i
Time: 1 Stage: 0 instr:   %tmp29.i = lshr i64 %11, 28
Time: 1 Stage: 0 instr:   %tmp30.i = trunc i64 %tmp29.i to i32
Time: 1 Stage: 0 instr:   %tmp31.i = sub i32 %tmp26.i, %tmp30.i
Time: 1 Stage: 0 instr:   %tmp40.i = add i32 %tmp39.i, %16
Stage: 1
Time: 2 Stage: 1 instr:   %17 = icmp slt i64 %13, 1073741825
Time: 2 Stage: 1 instr:   %18 = zext i1 %17 to i8
Time: 2 Stage: 1 instr:   %19 = add i8 %18, %fiter.013.i


Pipeline Table:
Total pipeline stages: 2
Stage:               0                             1
   II:        0              1     |        0              1
 Time:        0              1     |        2              3
   %fiter.013.i              -   %fiter.013.i              -
    %iter.012.i              -    %iter.012.i              -
       %y.011.i              -       %y.011.i              -
       %x.010.i              -       %x.010.i              -
       <badref>              -       <badref>              -
             %7              -             %7              -
             %8              -             %8              -
              -             %9              -             %9
            %10              -            %10              -
            %11              -            %11              -
              -            %12              -            %12
              -            %13              -            %13
            %14              -            %14              -
              -            %15              -            %15
              -         %.tr.i              -         %.tr.i
              -            %16              -            %16
              -              -            %17              -
              -              -            %18              -
              -              -            %19              -
            %20              -            %20              -
    %exitcond.i              -    %exitcond.i              -
              -       %tmp24.i              -       %tmp24.i
              -       %tmp25.i              -       %tmp25.i
              -       %tmp26.i              -       %tmp26.i
              -       %tmp29.i              -       %tmp29.i
              -       %tmp30.i              -       %tmp30.i
              -       %tmp31.i              -       %tmp31.i
              -       %tmp40.i              -       %tmp40.i
       <badref>              -       <badref>              -

