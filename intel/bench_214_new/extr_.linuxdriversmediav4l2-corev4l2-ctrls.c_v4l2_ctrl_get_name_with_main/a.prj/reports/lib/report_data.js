var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[0.00195904, 0.00163858, 0.000526685, 0, 0], "total":[14, 9, 0, 0, 0], "name":"System", "max_resources":[854400, 1708800, 2713, 1518, 42720], "children":[{"name":"main", "compute_units":1, "type":"function", "total_percent":[0.00195904, 0.00163858, 0.000526685, 0, 0], "total_kernel_resources":[14, 9, 0, 0, 0], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 32 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"32b wide with 0 elements."}]}, {"name":"main.B1.start", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[7, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:717", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1, 0, 0, 0, 0], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:717", "type":"resource", "data":[3, 0, 0, 0, 0], "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:720", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":720}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"children":[{"children":[{"data":[8,7,0,0,0],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Component call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 32 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"32b wide with 0 elements.","type":"brief"}],"name":"Component return","type":"resource"},{"children":[{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c","line":717}]],"name":"Stream Read","type":"resource"}],"data":[3,0,0,0,0],"debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c","line":717}]],"name":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:717","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c","line":720}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c","line":720}]],"name":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:720","replace_name":"true","type":"resource"}],"compute_units":1,"data":[14,9,0,0,0],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"main","total_kernel_resources":[14,9,0,0,0],"total_percent":[0.00195904,0.00163858,0.000526685,0,0],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[14,9,0,0,0],"debug_enabled":"true","max_resources":[854400,1708800,2713,1518,42720],"name":"System","total":[14,9,0,0,0],"total_percent":[0.00195904,0.00163858,0.000526685,0,0],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"main", "children":[{"type":"bb", "id":3, "name":"main.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"main.B1.start", "children":[{"type":"inst", "id":5, "name":"Stream Read", "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"1", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":7, "name":"Stream Write", "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":720}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"1", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":9, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"10"}]}, {"type":"inst", "id":10, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"1", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"1", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"stream", "id":6, "name":"call.main", "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":8, "name":"return.main", "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]], "details":[{"type":"table", "Width":"32 bits", "Depth":"0", "Bits per symbol":"32 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}], "links":[{"from":6, "to":5}, {"from":7, "to":8}, {"from":10, "to":9}, {"from":3, "to":9}, {"from":5, "to":10}, {"from":7, "to":10}, {"from":9, "to":5}, {"from":5, "to":7}]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Component: main", "data":["", "", ""], "debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"main.B1.start", "data":["Yes", "~1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: n/a"}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Stream Read Operation (%L)", "links":[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":"717"}]}, {"type":"text", "text":"Stream Write Operation (%L)", "links":[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":"720"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}]}';
var fmax_iiJSON='{"basicblocks":{"main.B0.runOnce":{"name":"main.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"240.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "main.B1.start":{"name":"main.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"240.0", "achieved_ii":1, "latency":1, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}}, "functions":{"main":{"debug":[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "line":717}], "loop_hierachy":{"main__no_loop":["main.B0.runOnce"], "main.B1.start":["main.B1.start"]}}}}';
var summaryJSON='{"functionNameMapping":{"name":"Synthesized Function Name Mapping", "columns":["User-defined Function Name", "Mapped Function Name"], "children":[{"name":"main", "data":["main"], "debug":[[{"filename":"", "line":0}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Function Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"main", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"", "line":0}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[14, 9, 0, 0, 0], "data_percent":[0.00163858, 0.000526685, 0, 0]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[854400, 1708800, 2713, 1518, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"classes":["info-table"],"data":["./a"],"name":"Project Name"},{"data":["Arria10, 10AX115U1F45I1SG"],"name":"Target Family, Device"},{"data":["19.4.0 Build 64"],"name":"i++ Version"},{"data":["19.4.0 Build 64 Pro"],"name":"Quartus Version"},{"data":["i++ -march=Arria10 --simulator none bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c"],"name":"Command"},{"data":["Sun May 24 19:51:41 2020"],"name":"Reports Generated At"}]}';
var warningsJSON='{"rows":[{"debug":[[{"filename":"bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c","line":719}]],"details":["bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c:719:22: warning: variable \'id\' is uninitialized when used here [-Wuninitialized]"],"name":"variable \'id\' is uninitialized when used here [-Wuninitialized]"}]}';
var quartusJSON='{"quartusFitClockSummary":{"children":[{"details":[{"text":"This section contains a summary of the area and f<sub>MAX</sub> data generated by compiling the components through Quartus. \\nTo generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./a.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n","type":"text"}],"name":"Run Quartus compile to populate this section. See details for more information."}],"name":"Quartus Fit Summary"}}';
var fileJSON=[{"path":"/opt/altera_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "name":"_task_FPGA.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "content":"#ifndef _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#define _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#include \"HLS/function_traits.h\"\012\012namespace ihc {\012  namespace internal {\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Identify the functionality\012    //   task<function>::instance()\012    // * Launch the calculations\012    //   task<function>::instance().launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::instance().collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    template<typename X, X& f, bool detach = false>\012    class _task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Constructor\012      _task() {}\012\012      // Disable copy-assignment operator\012      _task& operator=(const _task& rhs) = delete;\012\012      // Disable copy constructor\012      _task(const _task& other) = delete;\012\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      template<int capacity, typename ... Args>\012      void launch(Args&&... args) {\012        __builtin_intel_hls_enqueue(capacity, f, std::forward<Args>(args)...);\012      } // launch\012\012      template<int capacity>\012      T collect() {\012        return static_cast<T>(__builtin_intel_hls_get(capacity, f));\012      }\012\012    }; // class _task\012\012  } //namespace internal\012} // namespace ihc\012\012#endif // _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012"}, {"path":"/home/canesche/HLStools/intel/bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "name":"extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "has_active_debug_locs":false, "absName":"/home/canesche/HLStools/intel/bench_214_new/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main/extr_.linuxdriversmediav4l2-corev4l2-ctrls.c_v4l2_ctrl_get_name_with_main.c", "content":"#include \"HLS/hls.h\"\012typedef unsigned long size_t;  // Customize by platform.\012typedef int scalar_t__;  // Either arithmetic or pointer type.\012/* By default, we understand bool (as a convenience). */\012#define false 0\012#define true 1\012\012/* Forward declarations */\012\012/* Type definitions */\012typedef  int u32 ;\012\012/* Variables and functions */\012#define  V4L2_CID_3A_LOCK 455 \012#define  V4L2_CID_ALPHA_COMPONENT 454 \012#define  V4L2_CID_ANALOGUE_GAIN 453 \012#define  V4L2_CID_AUDIO_BALANCE 452 \012#define  V4L2_CID_AUDIO_BASS 451 \012#define  V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME 450 \012#define  V4L2_CID_AUDIO_COMPRESSION_ENABLED 449 \012#define  V4L2_CID_AUDIO_COMPRESSION_GAIN 448 \012#define  V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME 447 \012#define  V4L2_CID_AUDIO_COMPRESSION_THRESHOLD 446 \012#define  V4L2_CID_AUDIO_LIMITER_DEVIATION 445 \012#define  V4L2_CID_AUDIO_LIMITER_ENABLED 444 \012#define  V4L2_CID_AUDIO_LIMITER_RELEASE_TIME 443 \012#define  V4L2_CID_AUDIO_LOUDNESS 442 \012#define  V4L2_CID_AUDIO_MUTE 441 \012#define  V4L2_CID_AUDIO_TREBLE 440 \012#define  V4L2_CID_AUDIO_VOLUME 439 \012#define  V4L2_CID_AUTOBRIGHTNESS 438 \012#define  V4L2_CID_AUTOGAIN 437 \012#define  V4L2_CID_AUTO_EXPOSURE_BIAS 436 \012#define  V4L2_CID_AUTO_FOCUS_RANGE 435 \012#define  V4L2_CID_AUTO_FOCUS_START 434 \012#define  V4L2_CID_AUTO_FOCUS_STATUS 433 \012#define  V4L2_CID_AUTO_FOCUS_STOP 432 \012#define  V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE 431 \012#define  V4L2_CID_AUTO_WHITE_BALANCE 430 \012#define  V4L2_CID_BACKLIGHT_COMPENSATION 429 \012#define  V4L2_CID_BAND_STOP_FILTER 428 \012#define  V4L2_CID_BG_COLOR 427 \012#define  V4L2_CID_BLACK_LEVEL 426 \012#define  V4L2_CID_BLUE_BALANCE 425 \012#define  V4L2_CID_BRIGHTNESS 424 \012#define  V4L2_CID_CAMERA_CLASS 423 \012#define  V4L2_CID_CHROMA_AGC 422 \012#define  V4L2_CID_CHROMA_GAIN 421 \012#define  V4L2_CID_COLORFX 420 \012#define  V4L2_CID_COLORFX_CBCR 419 \012#define  V4L2_CID_COLOR_KILLER 418 \012#define  V4L2_CID_CONTRAST 417 \012#define  V4L2_CID_DEINTERLACING_MODE 416 \012#define  V4L2_CID_DETECT_CLASS 415 \012#define  V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD 414 \012#define  V4L2_CID_DETECT_MD_MODE 413 \012#define  V4L2_CID_DETECT_MD_REGION_GRID 412 \012#define  V4L2_CID_DETECT_MD_THRESHOLD_GRID 411 \012#define  V4L2_CID_DIGITAL_GAIN 410 \012#define  V4L2_CID_DO_WHITE_BALANCE 409 \012#define  V4L2_CID_DV_CLASS 408 \012#define  V4L2_CID_DV_RX_IT_CONTENT_TYPE 407 \012#define  V4L2_CID_DV_RX_POWER_PRESENT 406 \012#define  V4L2_CID_DV_RX_RGB_RANGE 405 \012#define  V4L2_CID_DV_TX_EDID_PRESENT 404 \012#define  V4L2_CID_DV_TX_HOTPLUG 403 \012#define  V4L2_CID_DV_TX_IT_CONTENT_TYPE 402 \012#define  V4L2_CID_DV_TX_MODE 401 \012#define  V4L2_CID_DV_TX_RGB_RANGE 400 \012#define  V4L2_CID_DV_TX_RXSENSE 399 \012#define  V4L2_CID_EXPOSURE 398 \012#define  V4L2_CID_EXPOSURE_ABSOLUTE 397 \012#define  V4L2_CID_EXPOSURE_AUTO 396 \012#define  V4L2_CID_EXPOSURE_AUTO_PRIORITY 395 \012#define  V4L2_CID_EXPOSURE_METERING 394 \012#define  V4L2_CID_FLASH_CHARGE 393 \012#define  V4L2_CID_FLASH_CLASS 392 \012#define  V4L2_CID_FLASH_FAULT 391 \012#define  V4L2_CID_FLASH_INDICATOR_INTENSITY 390 \012#define  V4L2_CID_FLASH_INTENSITY 389 \012#define  V4L2_CID_FLASH_LED_MODE 388 \012#define  V4L2_CID_FLASH_READY 387 \012#define  V4L2_CID_FLASH_STROBE 386 \012#define  V4L2_CID_FLASH_STROBE_SOURCE 385 \012#define  V4L2_CID_FLASH_STROBE_STATUS 384 \012#define  V4L2_CID_FLASH_STROBE_STOP 383 \012#define  V4L2_CID_FLASH_TIMEOUT 382 \012#define  V4L2_CID_FLASH_TORCH_INTENSITY 381 \012#define  V4L2_CID_FM_RX_CLASS 380 \012#define  V4L2_CID_FM_TX_CLASS 379 \012#define  V4L2_CID_FOCUS_ABSOLUTE 378 \012#define  V4L2_CID_FOCUS_AUTO 377 \012#define  V4L2_CID_FOCUS_RELATIVE 376 \012#define  V4L2_CID_GAIN 375 \012#define  V4L2_CID_GAMMA 374 \012#define  V4L2_CID_HBLANK 373 \012#define  V4L2_CID_HFLIP 372 \012#define  V4L2_CID_HUE 371 \012#define  V4L2_CID_HUE_AUTO 370 \012#define  V4L2_CID_ILLUMINATORS_1 369 \012#define  V4L2_CID_ILLUMINATORS_2 368 \012#define  V4L2_CID_IMAGE_PROC_CLASS 367 \012#define  V4L2_CID_IMAGE_SOURCE_CLASS 366 \012#define  V4L2_CID_IMAGE_STABILIZATION 365 \012#define  V4L2_CID_IRIS_ABSOLUTE 364 \012#define  V4L2_CID_IRIS_RELATIVE 363 \012#define  V4L2_CID_ISO_SENSITIVITY 362 \012#define  V4L2_CID_ISO_SENSITIVITY_AUTO 361 \012#define  V4L2_CID_JPEG_ACTIVE_MARKER 360 \012#define  V4L2_CID_JPEG_CHROMA_SUBSAMPLING 359 \012#define  V4L2_CID_JPEG_CLASS 358 \012#define  V4L2_CID_JPEG_COMPRESSION_QUALITY 357 \012#define  V4L2_CID_JPEG_RESTART_INTERVAL 356 \012#define  V4L2_CID_LINK_FREQ 355 \012#define  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE 354 \012#define  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT 353 \012#define  V4L2_CID_MPEG_AUDIO_AAC_BITRATE 352 \012#define  V4L2_CID_MPEG_AUDIO_AC3_BITRATE 351 \012#define  V4L2_CID_MPEG_AUDIO_CRC 350 \012#define  V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK 349 \012#define  V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK 348 \012#define  V4L2_CID_MPEG_AUDIO_EMPHASIS 347 \012#define  V4L2_CID_MPEG_AUDIO_ENCODING 346 \012#define  V4L2_CID_MPEG_AUDIO_L1_BITRATE 345 \012#define  V4L2_CID_MPEG_AUDIO_L2_BITRATE 344 \012#define  V4L2_CID_MPEG_AUDIO_L3_BITRATE 343 \012#define  V4L2_CID_MPEG_AUDIO_MODE 342 \012#define  V4L2_CID_MPEG_AUDIO_MODE_EXTENSION 341 \012#define  V4L2_CID_MPEG_AUDIO_MUTE 340 \012#define  V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ 339 \012#define  V4L2_CID_MPEG_CLASS 338 \012#define  V4L2_CID_MPEG_STREAM_PES_ID_AUDIO 337 \012#define  V4L2_CID_MPEG_STREAM_PES_ID_VIDEO 336 \012#define  V4L2_CID_MPEG_STREAM_PID_AUDIO 335 \012#define  V4L2_CID_MPEG_STREAM_PID_PCR 334 \012#define  V4L2_CID_MPEG_STREAM_PID_PMT 333 \012#define  V4L2_CID_MPEG_STREAM_PID_VIDEO 332 \012#define  V4L2_CID_MPEG_STREAM_TYPE 331 \012#define  V4L2_CID_MPEG_STREAM_VBI_FMT 330 \012#define  V4L2_CID_MPEG_VIDEO_ASPECT 329 \012#define  V4L2_CID_MPEG_VIDEO_BITRATE 328 \012#define  V4L2_CID_MPEG_VIDEO_BITRATE_MODE 327 \012#define  V4L2_CID_MPEG_VIDEO_BITRATE_PEAK 326 \012#define  V4L2_CID_MPEG_VIDEO_B_FRAMES 325 \012#define  V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB 324 \012#define  V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER 323 \012#define  V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE 322 \012#define  V4L2_CID_MPEG_VIDEO_DEC_FRAME 321 \012#define  V4L2_CID_MPEG_VIDEO_DEC_PTS 320 \012#define  V4L2_CID_MPEG_VIDEO_ENCODING 319 \012#define  V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME 318 \012#define  V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE 317 \012#define  V4L2_CID_MPEG_VIDEO_GOP_CLOSURE 316 \012#define  V4L2_CID_MPEG_VIDEO_GOP_SIZE 315 \012#define  V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP 314 \012#define  V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP 313 \012#define  V4L2_CID_MPEG_VIDEO_H263_MAX_QP 312 \012#define  V4L2_CID_MPEG_VIDEO_H263_MIN_QP 311 \012#define  V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP 310 \012#define  V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM 309 \012#define  V4L2_CID_MPEG_VIDEO_H264_ASO 308 \012#define  V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER 307 \012#define  V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP 306 \012#define  V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE 305 \012#define  V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE 304 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO 303 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION 302 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE 301 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE 300 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH 299 \012#define  V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP 298 \012#define  V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING 297 \012#define  V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER 296 \012#define  V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP 295 \012#define  V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE 294 \012#define  V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP 293 \012#define  V4L2_CID_MPEG_VIDEO_H264_I_PERIOD 292 \012#define  V4L2_CID_MPEG_VIDEO_H264_LEVEL 291 \012#define  V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA 290 \012#define  V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA 289 \012#define  V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE 288 \012#define  V4L2_CID_MPEG_VIDEO_H264_MAX_QP 287 \012#define  V4L2_CID_MPEG_VIDEO_H264_MIN_QP 286 \012#define  V4L2_CID_MPEG_VIDEO_H264_PROFILE 285 \012#define  V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP 284 \012#define  V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE 283 \012#define  V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0 282 \012#define  V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING 281 \012#define  V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT 280 \012#define  V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH 279 \012#define  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE 278 \012#define  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC 277 \012#define  V4L2_CID_MPEG_VIDEO_HEADER_MODE 276 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP 275 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED 274 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION 273 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB 272 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR 271 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP 270 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR 269 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP 268 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR 267 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP 266 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR 265 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP 264 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR 263 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP 262 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR 261 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP 260 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR 259 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP 258 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER 257 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE 256 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP 255 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT 254 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP 253 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_LEVEL 252 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2 251 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2 250 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE 249 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU 248 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1 247 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH 246 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP 245 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP 244 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_PROFILE 243 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP 242 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD 241 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE 240 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD 239 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING 238 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID 237 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_TIER 236 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION 235 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT 234 \012#define  V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE 233 \012#define  V4L2_CID_MPEG_VIDEO_MAX_REF_PIC 232 \012#define  V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE 231 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP 230 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP 229 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL 228 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP 227 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP 226 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE 225 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP 224 \012#define  V4L2_CID_MPEG_VIDEO_MPEG4_QPEL 223 \012#define  V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES 222 \012#define  V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB 221 \012#define  V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE 220 \012#define  V4L2_CID_MPEG_VIDEO_MUTE 219 \012#define  V4L2_CID_MPEG_VIDEO_MUTE_YUV 218 \012#define  V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE 217 \012#define  V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE 216 \012#define  V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR 215 \012#define  V4L2_CID_MPEG_VIDEO_PULLDOWN 214 \012#define  V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES 213 \012#define  V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER 212 \012#define  V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION 211 \012#define  V4L2_CID_MPEG_VIDEO_VBV_DELAY 210 \012#define  V4L2_CID_MPEG_VIDEO_VBV_SIZE 209 \012#define  V4L2_CID_MPEG_VIDEO_VP8_PROFILE 208 \012#define  V4L2_CID_MPEG_VIDEO_VP9_PROFILE 207 \012#define  V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL 206 \012#define  V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS 205 \012#define  V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD 204 \012#define  V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL 203 \012#define  V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4 202 \012#define  V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP 201 \012#define  V4L2_CID_MPEG_VIDEO_VPX_MAX_QP 200 \012#define  V4L2_CID_MPEG_VIDEO_VPX_MIN_QP 199 \012#define  V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS 198 \012#define  V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES 197 \012#define  V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP 196 \012#define  V4L2_CID_PAN_ABSOLUTE 195 \012#define  V4L2_CID_PAN_RELATIVE 194 \012#define  V4L2_CID_PAN_RESET 193 \012#define  V4L2_CID_PAN_SPEED 192 \012#define  V4L2_CID_PILOT_TONE_DEVIATION 191 \012#define  V4L2_CID_PILOT_TONE_ENABLED 190 \012#define  V4L2_CID_PILOT_TONE_FREQUENCY 189 \012#define  V4L2_CID_PIXEL_RATE 188 \012#define  V4L2_CID_POWER_LINE_FREQUENCY 187 \012#define  V4L2_CID_PRIVACY 186 \012#define  V4L2_CID_RDS_RECEPTION 185 \012#define  V4L2_CID_RDS_RX_MUSIC_SPEECH 184 \012#define  V4L2_CID_RDS_RX_PS_NAME 183 \012#define  V4L2_CID_RDS_RX_PTY 182 \012#define  V4L2_CID_RDS_RX_RADIO_TEXT 181 \012#define  V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT 180 \012#define  V4L2_CID_RDS_RX_TRAFFIC_PROGRAM 179 \012#define  V4L2_CID_RDS_TX_ALT_FREQS 178 \012#define  V4L2_CID_RDS_TX_ALT_FREQS_ENABLE 177 \012#define  V4L2_CID_RDS_TX_ARTIFICIAL_HEAD 176 \012#define  V4L2_CID_RDS_TX_COMPRESSED 175 \012#define  V4L2_CID_RDS_TX_DEVIATION 174 \012#define  V4L2_CID_RDS_TX_DYNAMIC_PTY 173 \012#define  V4L2_CID_RDS_TX_MONO_STEREO 172 \012#define  V4L2_CID_RDS_TX_MUSIC_SPEECH 171 \012#define  V4L2_CID_RDS_TX_PI 170 \012#define  V4L2_CID_RDS_TX_PS_NAME 169 \012#define  V4L2_CID_RDS_TX_PTY 168 \012#define  V4L2_CID_RDS_TX_RADIO_TEXT 167 \012#define  V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT 166 \012#define  V4L2_CID_RDS_TX_TRAFFIC_PROGRAM 165 \012#define  V4L2_CID_RED_BALANCE 164 \012#define  V4L2_CID_RF_TUNER_BANDWIDTH 163 \012#define  V4L2_CID_RF_TUNER_BANDWIDTH_AUTO 162 \012#define  V4L2_CID_RF_TUNER_CLASS 161 \012#define  V4L2_CID_RF_TUNER_IF_GAIN 160 \012#define  V4L2_CID_RF_TUNER_IF_GAIN_AUTO 159 \012#define  V4L2_CID_RF_TUNER_LNA_GAIN 158 \012#define  V4L2_CID_RF_TUNER_LNA_GAIN_AUTO 157 \012#define  V4L2_CID_RF_TUNER_MIXER_GAIN 156 \012#define  V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO 155 \012#define  V4L2_CID_RF_TUNER_PLL_LOCK 154 \012#define  V4L2_CID_RF_TUNER_RF_GAIN 153 \012#define  V4L2_CID_ROTATE 152 \012#define  V4L2_CID_SATURATION 151 \012#define  V4L2_CID_SCENE_MODE 150 \012#define  V4L2_CID_SHARPNESS 149 \012#define  V4L2_CID_TEST_PATTERN 148 \012#define  V4L2_CID_TEST_PATTERN_BLUE 147 \012#define  V4L2_CID_TEST_PATTERN_GREENB 146 \012#define  V4L2_CID_TEST_PATTERN_GREENR 145 \012#define  V4L2_CID_TEST_PATTERN_RED 144 \012#define  V4L2_CID_TILT_ABSOLUTE 143 \012#define  V4L2_CID_TILT_RELATIVE 142 \012#define  V4L2_CID_TILT_RESET 141 \012#define  V4L2_CID_TILT_SPEED 140 \012#define  V4L2_CID_TUNE_ANTENNA_CAPACITOR 139 \012#define  V4L2_CID_TUNE_DEEMPHASIS 138 \012#define  V4L2_CID_TUNE_POWER_LEVEL 137 \012#define  V4L2_CID_TUNE_PREEMPHASIS 136 \012#define  V4L2_CID_USER_CLASS 135 \012#define  V4L2_CID_VBLANK 134 \012#define  V4L2_CID_VFLIP 133 \012#define  V4L2_CID_WHITE_BALANCE_TEMPERATURE 132 \012#define  V4L2_CID_WIDE_DYNAMIC_RANGE 131 \012#define  V4L2_CID_ZOOM_ABSOLUTE 130 \012#define  V4L2_CID_ZOOM_CONTINUOUS 129 \012#define  V4L2_CID_ZOOM_RELATIVE 128 \012\012const char *v4l2_ctrl_get_name(u32 id)\012{\012	switch (id) {\012	/* USER controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_USER_CLASS:		return \"User Controls\";\012	case V4L2_CID_BRIGHTNESS:		return \"Brightness\";\012	case V4L2_CID_CONTRAST:			return \"Contrast\";\012	case V4L2_CID_SATURATION:		return \"Saturation\";\012	case V4L2_CID_HUE:			return \"Hue\";\012	case V4L2_CID_AUDIO_VOLUME:		return \"Volume\";\012	case V4L2_CID_AUDIO_BALANCE:		return \"Balance\";\012	case V4L2_CID_AUDIO_BASS:		return \"Bass\";\012	case V4L2_CID_AUDIO_TREBLE:		return \"Treble\";\012	case V4L2_CID_AUDIO_MUTE:		return \"Mute\";\012	case V4L2_CID_AUDIO_LOUDNESS:		return \"Loudness\";\012	case V4L2_CID_BLACK_LEVEL:		return \"Black Level\";\012	case V4L2_CID_AUTO_WHITE_BALANCE:	return \"White Balance, Automatic\";\012	case V4L2_CID_DO_WHITE_BALANCE:		return \"Do White Balance\";\012	case V4L2_CID_RED_BALANCE:		return \"Red Balance\";\012	case V4L2_CID_BLUE_BALANCE:		return \"Blue Balance\";\012	case V4L2_CID_GAMMA:			return \"Gamma\";\012	case V4L2_CID_EXPOSURE:			return \"Exposure\";\012	case V4L2_CID_AUTOGAIN:			return \"Gain, Automatic\";\012	case V4L2_CID_GAIN:			return \"Gain\";\012	case V4L2_CID_HFLIP:			return \"Horizontal Flip\";\012	case V4L2_CID_VFLIP:			return \"Vertical Flip\";\012	case V4L2_CID_POWER_LINE_FREQUENCY:	return \"Power Line Frequency\";\012	case V4L2_CID_HUE_AUTO:			return \"Hue, Automatic\";\012	case V4L2_CID_WHITE_BALANCE_TEMPERATURE: return \"White Balance Temperature\";\012	case V4L2_CID_SHARPNESS:		return \"Sharpness\";\012	case V4L2_CID_BACKLIGHT_COMPENSATION:	return \"Backlight Compensation\";\012	case V4L2_CID_CHROMA_AGC:		return \"Chroma AGC\";\012	case V4L2_CID_COLOR_KILLER:		return \"Color Killer\";\012	case V4L2_CID_COLORFX:			return \"Color Effects\";\012	case V4L2_CID_AUTOBRIGHTNESS:		return \"Brightness, Automatic\";\012	case V4L2_CID_BAND_STOP_FILTER:		return \"Band-Stop Filter\";\012	case V4L2_CID_ROTATE:			return \"Rotate\";\012	case V4L2_CID_BG_COLOR:			return \"Background Color\";\012	case V4L2_CID_CHROMA_GAIN:		return \"Chroma Gain\";\012	case V4L2_CID_ILLUMINATORS_1:		return \"Illuminator 1\";\012	case V4L2_CID_ILLUMINATORS_2:		return \"Illuminator 2\";\012	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:	return \"Min Number of Capture Buffers\";\012	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:	return \"Min Number of Output Buffers\";\012	case V4L2_CID_ALPHA_COMPONENT:		return \"Alpha Component\";\012	case V4L2_CID_COLORFX_CBCR:		return \"Color Effects, CbCr\";\012\012	/* Codec controls */\012	/* The MPEG controls are applicable to all codec controls\012	 * and the 'MPEG' part of the define is historical */\012	/* Keep the order of the 'case's the same as in videodev2.h! */\012	case V4L2_CID_MPEG_CLASS:		return \"Codec Controls\";\012	case V4L2_CID_MPEG_STREAM_TYPE:		return \"Stream Type\";\012	case V4L2_CID_MPEG_STREAM_PID_PMT:	return \"Stream PMT Program ID\";\012	case V4L2_CID_MPEG_STREAM_PID_AUDIO:	return \"Stream Audio Program ID\";\012	case V4L2_CID_MPEG_STREAM_PID_VIDEO:	return \"Stream Video Program ID\";\012	case V4L2_CID_MPEG_STREAM_PID_PCR:	return \"Stream PCR Program ID\";\012	case V4L2_CID_MPEG_STREAM_PES_ID_AUDIO: return \"Stream PES Audio ID\";\012	case V4L2_CID_MPEG_STREAM_PES_ID_VIDEO: return \"Stream PES Video ID\";\012	case V4L2_CID_MPEG_STREAM_VBI_FMT:	return \"Stream VBI Format\";\012	case V4L2_CID_MPEG_AUDIO_SAMPLING_FREQ: return \"Audio Sampling Frequency\";\012	case V4L2_CID_MPEG_AUDIO_ENCODING:	return \"Audio Encoding\";\012	case V4L2_CID_MPEG_AUDIO_L1_BITRATE:	return \"Audio Layer I Bitrate\";\012	case V4L2_CID_MPEG_AUDIO_L2_BITRATE:	return \"Audio Layer II Bitrate\";\012	case V4L2_CID_MPEG_AUDIO_L3_BITRATE:	return \"Audio Layer III Bitrate\";\012	case V4L2_CID_MPEG_AUDIO_MODE:		return \"Audio Stereo Mode\";\012	case V4L2_CID_MPEG_AUDIO_MODE_EXTENSION: return \"Audio Stereo Mode Extension\";\012	case V4L2_CID_MPEG_AUDIO_EMPHASIS:	return \"Audio Emphasis\";\012	case V4L2_CID_MPEG_AUDIO_CRC:		return \"Audio CRC\";\012	case V4L2_CID_MPEG_AUDIO_MUTE:		return \"Audio Mute\";\012	case V4L2_CID_MPEG_AUDIO_AAC_BITRATE:	return \"Audio AAC Bitrate\";\012	case V4L2_CID_MPEG_AUDIO_AC3_BITRATE:	return \"Audio AC-3 Bitrate\";\012	case V4L2_CID_MPEG_AUDIO_DEC_PLAYBACK:	return \"Audio Playback\";\012	case V4L2_CID_MPEG_AUDIO_DEC_MULTILINGUAL_PLAYBACK: return \"Audio Multilingual Playback\";\012	case V4L2_CID_MPEG_VIDEO_ENCODING:	return \"Video Encoding\";\012	case V4L2_CID_MPEG_VIDEO_ASPECT:	return \"Video Aspect\";\012	case V4L2_CID_MPEG_VIDEO_B_FRAMES:	return \"Video B Frames\";\012	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:	return \"Video GOP Size\";\012	case V4L2_CID_MPEG_VIDEO_GOP_CLOSURE:	return \"Video GOP Closure\";\012	case V4L2_CID_MPEG_VIDEO_PULLDOWN:	return \"Video Pulldown\";\012	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:	return \"Video Bitrate Mode\";\012	case V4L2_CID_MPEG_VIDEO_BITRATE:	return \"Video Bitrate\";\012	case V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:	return \"Video Peak Bitrate\";\012	case V4L2_CID_MPEG_VIDEO_TEMPORAL_DECIMATION: return \"Video Temporal Decimation\";\012	case V4L2_CID_MPEG_VIDEO_MUTE:		return \"Video Mute\";\012	case V4L2_CID_MPEG_VIDEO_MUTE_YUV:	return \"Video Mute YUV\";\012	case V4L2_CID_MPEG_VIDEO_DECODER_SLICE_INTERFACE:	return \"Decoder Slice Interface\";\012	case V4L2_CID_MPEG_VIDEO_DECODER_MPEG4_DEBLOCK_FILTER:	return \"MPEG4 Loop Filter Enable\";\012	case V4L2_CID_MPEG_VIDEO_CYCLIC_INTRA_REFRESH_MB:	return \"Number of Intra Refresh MBs\";\012	case V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:		return \"Frame Level Rate Control Enable\";\012	case V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:			return \"H264 MB Level Rate Control\";\012	case V4L2_CID_MPEG_VIDEO_HEADER_MODE:			return \"Sequence Header Mode\";\012	case V4L2_CID_MPEG_VIDEO_MAX_REF_PIC:			return \"Max Number of Reference Pics\";\012	case V4L2_CID_MPEG_VIDEO_H263_I_FRAME_QP:		return \"H263 I-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H263_P_FRAME_QP:		return \"H263 P-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H263_B_FRAME_QP:		return \"H263 B-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H263_MIN_QP:			return \"H263 Minimum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H263_MAX_QP:			return \"H263 Maximum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:		return \"H264 I-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_P_FRAME_QP:		return \"H264 P-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_B_FRAME_QP:		return \"H264 B-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_MAX_QP:			return \"H264 Maximum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_MIN_QP:			return \"H264 Minimum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:		return \"H264 8x8 Transform Enable\";\012	case V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:			return \"H264 CPB Buffer Size\";\012	case V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:		return \"H264 Entropy Mode\";\012	case V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:			return \"H264 I-Frame Period\";\012	case V4L2_CID_MPEG_VIDEO_H264_LEVEL:			return \"H264 Level\";\012	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:	return \"H264 Loop Filter Alpha Offset\";\012	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:		return \"H264 Loop Filter Beta Offset\";\012	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:		return \"H264 Loop Filter Mode\";\012	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:			return \"H264 Profile\";\012	case V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_HEIGHT:	return \"Vertical Size of SAR\";\012	case V4L2_CID_MPEG_VIDEO_H264_VUI_EXT_SAR_WIDTH:	return \"Horizontal Size of SAR\";\012	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:		return \"Aspect Ratio VUI Enable\";\012	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:		return \"VUI Aspect Ratio IDC\";\012	case V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:	return \"H264 Enable Frame Packing SEI\";\012	case V4L2_CID_MPEG_VIDEO_H264_SEI_FP_CURRENT_FRAME_0:	return \"H264 Set Curr. Frame as Frame0\";\012	case V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:	return \"H264 FP Arrangement Type\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO:			return \"H264 Flexible MB Ordering\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO_MAP_TYPE:		return \"H264 Map Type for FMO\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO_SLICE_GROUP:		return \"H264 FMO Number of Slice Groups\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_DIRECTION:	return \"H264 FMO Direction of Change\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO_CHANGE_RATE:		return \"H264 FMO Size of 1st Slice Grp\";\012	case V4L2_CID_MPEG_VIDEO_H264_FMO_RUN_LENGTH:		return \"H264 FMO No. of Consecutive MBs\";\012	case V4L2_CID_MPEG_VIDEO_H264_ASO:			return \"H264 Arbitrary Slice Ordering\";\012	case V4L2_CID_MPEG_VIDEO_H264_ASO_SLICE_ORDER:		return \"H264 ASO Slice Order\";\012	case V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING:	return \"Enable H264 Hierarchical Coding\";\012	case V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_TYPE:	return \"H264 Hierarchical Coding Type\";\012	case V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER:return \"H264 Number of HC Layers\";\012	case V4L2_CID_MPEG_VIDEO_H264_HIERARCHICAL_CODING_LAYER_QP:\012								return \"H264 Set QP Value for HC Layers\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_I_FRAME_QP:		return \"MPEG4 I-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_P_FRAME_QP:		return \"MPEG4 P-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_B_FRAME_QP:		return \"MPEG4 B-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_MIN_QP:			return \"MPEG4 Minimum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_MAX_QP:			return \"MPEG4 Maximum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_LEVEL:			return \"MPEG4 Level\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_PROFILE:			return \"MPEG4 Profile\";\012	case V4L2_CID_MPEG_VIDEO_MPEG4_QPEL:			return \"Quarter Pixel Search Enable\";\012	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_BYTES:		return \"Maximum Bytes in a Slice\";\012	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:		return \"Number of MBs in a Slice\";\012	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:		return \"Slice Partitioning Method\";\012	case V4L2_CID_MPEG_VIDEO_VBV_SIZE:			return \"VBV Buffer Size\";\012	case V4L2_CID_MPEG_VIDEO_DEC_PTS:			return \"Video Decoder PTS\";\012	case V4L2_CID_MPEG_VIDEO_DEC_FRAME:			return \"Video Decoder Frame Count\";\012	case V4L2_CID_MPEG_VIDEO_VBV_DELAY:			return \"Initial Delay for VBV Control\";\012	case V4L2_CID_MPEG_VIDEO_MV_H_SEARCH_RANGE:		return \"Horizontal MV Search Range\";\012	case V4L2_CID_MPEG_VIDEO_MV_V_SEARCH_RANGE:		return \"Vertical MV Search Range\";\012	case V4L2_CID_MPEG_VIDEO_REPEAT_SEQ_HEADER:		return \"Repeat Sequence Header\";\012	case V4L2_CID_MPEG_VIDEO_FORCE_KEY_FRAME:		return \"Force Key Frame\";\012\012	/* VPX controls */\012	case V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:		return \"VPX Number of Partitions\";\012	case V4L2_CID_MPEG_VIDEO_VPX_IMD_DISABLE_4X4:		return \"VPX Intra Mode Decision Disable\";\012	case V4L2_CID_MPEG_VIDEO_VPX_NUM_REF_FRAMES:		return \"VPX No. of Refs for P Frame\";\012	case V4L2_CID_MPEG_VIDEO_VPX_FILTER_LEVEL:		return \"VPX Loop Filter Level Range\";\012	case V4L2_CID_MPEG_VIDEO_VPX_FILTER_SHARPNESS:		return \"VPX Deblocking Effect Control\";\012	case V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_REF_PERIOD:	return \"VPX Golden Frame Refresh Period\";\012	case V4L2_CID_MPEG_VIDEO_VPX_GOLDEN_FRAME_SEL:		return \"VPX Golden Frame Indicator\";\012	case V4L2_CID_MPEG_VIDEO_VPX_MIN_QP:			return \"VPX Minimum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_VPX_MAX_QP:			return \"VPX Maximum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_VPX_I_FRAME_QP:		return \"VPX I-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_VPX_P_FRAME_QP:		return \"VPX P-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_VP8_PROFILE:			return \"VP8 Profile\";\012	case V4L2_CID_MPEG_VIDEO_VP9_PROFILE:			return \"VP9 Profile\";\012\012	/* HEVC controls */\012	case V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP:		return \"HEVC I-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_P_FRAME_QP:		return \"HEVC P-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_B_FRAME_QP:		return \"HEVC B-Frame QP Value\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP:			return \"HEVC Minimum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP:			return \"HEVC Maximum QP Value\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_PROFILE:			return \"HEVC Profile\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_LEVEL:			return \"HEVC Level\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_TIER:			return \"HEVC Tier\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_FRAME_RATE_RESOLUTION:	return \"HEVC Frame Rate Resolution\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_PARTITION_DEPTH:	return \"HEVC Maximum Coding Unit Depth\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE:		return \"HEVC Refresh Type\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED:		return \"HEVC Constant Intra Prediction\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU:		return \"HEVC Lossless Encoding\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT:		return \"HEVC Wavefront\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE:		return \"HEVC Loop Filter\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_QP:			return \"HEVC QP Values\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_TYPE:		return \"HEVC Hierarchical Coding Type\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_LAYER:	return \"HEVC Hierarchical Coding Layer\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_QP:	return \"HEVC Hierarchical Layer 0 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_QP:	return \"HEVC Hierarchical Layer 1 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_QP:	return \"HEVC Hierarchical Layer 2 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_QP:	return \"HEVC Hierarchical Layer 3 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_QP:	return \"HEVC Hierarchical Layer 4 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_QP:	return \"HEVC Hierarchical Layer 5 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_QP:	return \"HEVC Hierarchical Layer 6 QP\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L0_BR:	return \"HEVC Hierarchical Lay 0 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L1_BR:	return \"HEVC Hierarchical Lay 1 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L2_BR:	return \"HEVC Hierarchical Lay 2 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L3_BR:	return \"HEVC Hierarchical Lay 3 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L4_BR:	return \"HEVC Hierarchical Lay 4 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L5_BR:	return \"HEVC Hierarchical Lay 5 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_HIER_CODING_L6_BR:	return \"HEVC Hierarchical Lay 6 BitRate\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_GENERAL_PB:		return \"HEVC General PB\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_TEMPORAL_ID:		return \"HEVC Temporal ID\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING:		return \"HEVC Strong Intra Smoothing\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_INTRA_PU_SPLIT:		return \"HEVC Intra PU Split\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION:		return \"HEVC TMV Prediction\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1:	return \"HEVC Max Num of Candidate MVs\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_WITHOUT_STARTCODE:	return \"HEVC ENC Without Startcode\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD:		return \"HEVC Num of I-Frame b/w 2 IDR\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2:	return \"HEVC Loop Filter Beta Offset\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2:	return \"HEVC Loop Filter TC Offset\";\012	case V4L2_CID_MPEG_VIDEO_HEVC_SIZE_OF_LENGTH_FIELD:	return \"HEVC Size of Length Field\";\012	case V4L2_CID_MPEG_VIDEO_REF_NUMBER_FOR_PFRAMES:	return \"Reference Frames for a P-Frame\";\012	case V4L2_CID_MPEG_VIDEO_PREPEND_SPSPPS_TO_IDR:		return \"Prepend SPS and PPS to IDR\";\012\012	/* CAMERA controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_CAMERA_CLASS:		return \"Camera Controls\";\012	case V4L2_CID_EXPOSURE_AUTO:		return \"Auto Exposure\";\012	case V4L2_CID_EXPOSURE_ABSOLUTE:	return \"Exposure Time, Absolute\";\012	case V4L2_CID_EXPOSURE_AUTO_PRIORITY:	return \"Exposure, Dynamic Framerate\";\012	case V4L2_CID_PAN_RELATIVE:		return \"Pan, Relative\";\012	case V4L2_CID_TILT_RELATIVE:		return \"Tilt, Relative\";\012	case V4L2_CID_PAN_RESET:		return \"Pan, Reset\";\012	case V4L2_CID_TILT_RESET:		return \"Tilt, Reset\";\012	case V4L2_CID_PAN_ABSOLUTE:		return \"Pan, Absolute\";\012	case V4L2_CID_TILT_ABSOLUTE:		return \"Tilt, Absolute\";\012	case V4L2_CID_FOCUS_ABSOLUTE:		return \"Focus, Absolute\";\012	case V4L2_CID_FOCUS_RELATIVE:		return \"Focus, Relative\";\012	case V4L2_CID_FOCUS_AUTO:		return \"Focus, Automatic Continuous\";\012	case V4L2_CID_ZOOM_ABSOLUTE:		return \"Zoom, Absolute\";\012	case V4L2_CID_ZOOM_RELATIVE:		return \"Zoom, Relative\";\012	case V4L2_CID_ZOOM_CONTINUOUS:		return \"Zoom, Continuous\";\012	case V4L2_CID_PRIVACY:			return \"Privacy\";\012	case V4L2_CID_IRIS_ABSOLUTE:		return \"Iris, Absolute\";\012	case V4L2_CID_IRIS_RELATIVE:		return \"Iris, Relative\";\012	case V4L2_CID_AUTO_EXPOSURE_BIAS:	return \"Auto Exposure, Bias\";\012	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE: return \"White Balance, Auto & Preset\";\012	case V4L2_CID_WIDE_DYNAMIC_RANGE:	return \"Wide Dynamic Range\";\012	case V4L2_CID_IMAGE_STABILIZATION:	return \"Image Stabilization\";\012	case V4L2_CID_ISO_SENSITIVITY:		return \"ISO Sensitivity\";\012	case V4L2_CID_ISO_SENSITIVITY_AUTO:	return \"ISO Sensitivity, Auto\";\012	case V4L2_CID_EXPOSURE_METERING:	return \"Exposure, Metering Mode\";\012	case V4L2_CID_SCENE_MODE:		return \"Scene Mode\";\012	case V4L2_CID_3A_LOCK:			return \"3A Lock\";\012	case V4L2_CID_AUTO_FOCUS_START:		return \"Auto Focus, Start\";\012	case V4L2_CID_AUTO_FOCUS_STOP:		return \"Auto Focus, Stop\";\012	case V4L2_CID_AUTO_FOCUS_STATUS:	return \"Auto Focus, Status\";\012	case V4L2_CID_AUTO_FOCUS_RANGE:		return \"Auto Focus, Range\";\012	case V4L2_CID_PAN_SPEED:		return \"Pan, Speed\";\012	case V4L2_CID_TILT_SPEED:		return \"Tilt, Speed\";\012\012	/* FM Radio Modulator controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_FM_TX_CLASS:		return \"FM Radio Modulator Controls\";\012	case V4L2_CID_RDS_TX_DEVIATION:		return \"RDS Signal Deviation\";\012	case V4L2_CID_RDS_TX_PI:		return \"RDS Program ID\";\012	case V4L2_CID_RDS_TX_PTY:		return \"RDS Program Type\";\012	case V4L2_CID_RDS_TX_PS_NAME:		return \"RDS PS Name\";\012	case V4L2_CID_RDS_TX_RADIO_TEXT:	return \"RDS Radio Text\";\012	case V4L2_CID_RDS_TX_MONO_STEREO:	return \"RDS Stereo\";\012	case V4L2_CID_RDS_TX_ARTIFICIAL_HEAD:	return \"RDS Artificial Head\";\012	case V4L2_CID_RDS_TX_COMPRESSED:	return \"RDS Compressed\";\012	case V4L2_CID_RDS_TX_DYNAMIC_PTY:	return \"RDS Dynamic PTY\";\012	case V4L2_CID_RDS_TX_TRAFFIC_ANNOUNCEMENT: return \"RDS Traffic Announcement\";\012	case V4L2_CID_RDS_TX_TRAFFIC_PROGRAM:	return \"RDS Traffic Program\";\012	case V4L2_CID_RDS_TX_MUSIC_SPEECH:	return \"RDS Music\";\012	case V4L2_CID_RDS_TX_ALT_FREQS_ENABLE:	return \"RDS Enable Alt Frequencies\";\012	case V4L2_CID_RDS_TX_ALT_FREQS:		return \"RDS Alternate Frequencies\";\012	case V4L2_CID_AUDIO_LIMITER_ENABLED:	return \"Audio Limiter Feature Enabled\";\012	case V4L2_CID_AUDIO_LIMITER_RELEASE_TIME: return \"Audio Limiter Release Time\";\012	case V4L2_CID_AUDIO_LIMITER_DEVIATION:	return \"Audio Limiter Deviation\";\012	case V4L2_CID_AUDIO_COMPRESSION_ENABLED: return \"Audio Compression Enabled\";\012	case V4L2_CID_AUDIO_COMPRESSION_GAIN:	return \"Audio Compression Gain\";\012	case V4L2_CID_AUDIO_COMPRESSION_THRESHOLD: return \"Audio Compression Threshold\";\012	case V4L2_CID_AUDIO_COMPRESSION_ATTACK_TIME: return \"Audio Compression Attack Time\";\012	case V4L2_CID_AUDIO_COMPRESSION_RELEASE_TIME: return \"Audio Compression Release Time\";\012	case V4L2_CID_PILOT_TONE_ENABLED:	return \"Pilot Tone Feature Enabled\";\012	case V4L2_CID_PILOT_TONE_DEVIATION:	return \"Pilot Tone Deviation\";\012	case V4L2_CID_PILOT_TONE_FREQUENCY:	return \"Pilot Tone Frequency\";\012	case V4L2_CID_TUNE_PREEMPHASIS:		return \"Pre-Emphasis\";\012	case V4L2_CID_TUNE_POWER_LEVEL:		return \"Tune Power Level\";\012	case V4L2_CID_TUNE_ANTENNA_CAPACITOR:	return \"Tune Antenna Capacitor\";\012\012	/* Flash controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_FLASH_CLASS:		return \"Flash Controls\";\012	case V4L2_CID_FLASH_LED_MODE:		return \"LED Mode\";\012	case V4L2_CID_FLASH_STROBE_SOURCE:	return \"Strobe Source\";\012	case V4L2_CID_FLASH_STROBE:		return \"Strobe\";\012	case V4L2_CID_FLASH_STROBE_STOP:	return \"Stop Strobe\";\012	case V4L2_CID_FLASH_STROBE_STATUS:	return \"Strobe Status\";\012	case V4L2_CID_FLASH_TIMEOUT:		return \"Strobe Timeout\";\012	case V4L2_CID_FLASH_INTENSITY:		return \"Intensity, Flash Mode\";\012	case V4L2_CID_FLASH_TORCH_INTENSITY:	return \"Intensity, Torch Mode\";\012	case V4L2_CID_FLASH_INDICATOR_INTENSITY: return \"Intensity, Indicator\";\012	case V4L2_CID_FLASH_FAULT:		return \"Faults\";\012	case V4L2_CID_FLASH_CHARGE:		return \"Charge\";\012	case V4L2_CID_FLASH_READY:		return \"Ready to Strobe\";\012\012	/* JPEG encoder controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_JPEG_CLASS:		return \"JPEG Compression Controls\";\012	case V4L2_CID_JPEG_CHROMA_SUBSAMPLING:	return \"Chroma Subsampling\";\012	case V4L2_CID_JPEG_RESTART_INTERVAL:	return \"Restart Interval\";\012	case V4L2_CID_JPEG_COMPRESSION_QUALITY:	return \"Compression Quality\";\012	case V4L2_CID_JPEG_ACTIVE_MARKER:	return \"Active Markers\";\012\012	/* Image source controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_IMAGE_SOURCE_CLASS:	return \"Image Source Controls\";\012	case V4L2_CID_VBLANK:			return \"Vertical Blanking\";\012	case V4L2_CID_HBLANK:			return \"Horizontal Blanking\";\012	case V4L2_CID_ANALOGUE_GAIN:		return \"Analogue Gain\";\012	case V4L2_CID_TEST_PATTERN_RED:		return \"Red Pixel Value\";\012	case V4L2_CID_TEST_PATTERN_GREENR:	return \"Green (Red) Pixel Value\";\012	case V4L2_CID_TEST_PATTERN_BLUE:	return \"Blue Pixel Value\";\012	case V4L2_CID_TEST_PATTERN_GREENB:	return \"Green (Blue) Pixel Value\";\012\012	/* Image processing controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_IMAGE_PROC_CLASS:		return \"Image Processing Controls\";\012	case V4L2_CID_LINK_FREQ:		return \"Link Frequency\";\012	case V4L2_CID_PIXEL_RATE:		return \"Pixel Rate\";\012	case V4L2_CID_TEST_PATTERN:		return \"Test Pattern\";\012	case V4L2_CID_DEINTERLACING_MODE:	return \"Deinterlacing Mode\";\012	case V4L2_CID_DIGITAL_GAIN:		return \"Digital Gain\";\012\012	/* DV controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_DV_CLASS:			return \"Digital Video Controls\";\012	case V4L2_CID_DV_TX_HOTPLUG:		return \"Hotplug Present\";\012	case V4L2_CID_DV_TX_RXSENSE:		return \"RxSense Present\";\012	case V4L2_CID_DV_TX_EDID_PRESENT:	return \"EDID Present\";\012	case V4L2_CID_DV_TX_MODE:		return \"Transmit Mode\";\012	case V4L2_CID_DV_TX_RGB_RANGE:		return \"Tx RGB Quantization Range\";\012	case V4L2_CID_DV_TX_IT_CONTENT_TYPE:	return \"Tx IT Content Type\";\012	case V4L2_CID_DV_RX_POWER_PRESENT:	return \"Power Present\";\012	case V4L2_CID_DV_RX_RGB_RANGE:		return \"Rx RGB Quantization Range\";\012	case V4L2_CID_DV_RX_IT_CONTENT_TYPE:	return \"Rx IT Content Type\";\012\012	case V4L2_CID_FM_RX_CLASS:		return \"FM Radio Receiver Controls\";\012	case V4L2_CID_TUNE_DEEMPHASIS:		return \"De-Emphasis\";\012	case V4L2_CID_RDS_RECEPTION:		return \"RDS Reception\";\012	case V4L2_CID_RF_TUNER_CLASS:		return \"RF Tuner Controls\";\012	case V4L2_CID_RF_TUNER_RF_GAIN:		return \"RF Gain\";\012	case V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:	return \"LNA Gain, Auto\";\012	case V4L2_CID_RF_TUNER_LNA_GAIN:	return \"LNA Gain\";\012	case V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:	return \"Mixer Gain, Auto\";\012	case V4L2_CID_RF_TUNER_MIXER_GAIN:	return \"Mixer Gain\";\012	case V4L2_CID_RF_TUNER_IF_GAIN_AUTO:	return \"IF Gain, Auto\";\012	case V4L2_CID_RF_TUNER_IF_GAIN:		return \"IF Gain\";\012	case V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:	return \"Bandwidth, Auto\";\012	case V4L2_CID_RF_TUNER_BANDWIDTH:	return \"Bandwidth\";\012	case V4L2_CID_RF_TUNER_PLL_LOCK:	return \"PLL Lock\";\012	case V4L2_CID_RDS_RX_PTY:		return \"RDS Program Type\";\012	case V4L2_CID_RDS_RX_PS_NAME:		return \"RDS PS Name\";\012	case V4L2_CID_RDS_RX_RADIO_TEXT:	return \"RDS Radio Text\";\012	case V4L2_CID_RDS_RX_TRAFFIC_ANNOUNCEMENT: return \"RDS Traffic Announcement\";\012	case V4L2_CID_RDS_RX_TRAFFIC_PROGRAM:	return \"RDS Traffic Program\";\012	case V4L2_CID_RDS_RX_MUSIC_SPEECH:	return \"RDS Music\";\012\012	/* Detection controls */\012	/* Keep the order of the 'case's the same as in v4l2-controls.h! */\012	case V4L2_CID_DETECT_CLASS:		return \"Detection Controls\";\012	case V4L2_CID_DETECT_MD_MODE:		return \"Motion Detection Mode\";\012	case V4L2_CID_DETECT_MD_GLOBAL_THRESHOLD: return \"MD Global Threshold\";\012	case V4L2_CID_DETECT_MD_THRESHOLD_GRID:	return \"MD Threshold Grid\";\012	case V4L2_CID_DETECT_MD_REGION_GRID:	return \"MD Region Grid\";\012	default:\012		return 0;\012	}\012}\012\012/* Main routine for v4l2_ctrl_get_name */\012component int main() {\012  u32 id;\012  v4l2_ctrl_get_name(id);\012  return 0;\012}\012"}, {"path":"/opt/altera_pro/19.4/hls/include/HLS/function_traits.h", "name":"function_traits.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/function_traits.h", "content":"#ifndef _INTEL_IHC_HLS_FUNCTION_TRAITS\012#define _INTEL_IHC_HLS_FUNCTION_TRAITS\012\012namespace ihc {\012  // Some metaprogramming to extract the return type\012  // from a function type\012  template<typename F>\012  struct function_traits {\012    using return_type = F;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(*)(Args...)>\012  {\012    using return_type = R;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(&)(Args...)>\012  {\012    using return_type = R;\012  };\012}\012\012#endif // _INTEL_IHC_HLS_FUNCTION_TRAITS\012"}, {"path":"/opt/altera_pro/19.4/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifdef __INTELFPGA_COMPILER__\012   // Compiling for FPGA or x86 using FPGA compiler\012#  undef component\012#  define component __attribute__((ihc_component)) __attribute__((noinline))\012#else\012#  ifndef component\012#    define component\012#  endif\012#  ifndef HLS_X86\012#    define HLS_X86\012#  endif\012#endif\012#include <type_traits>\012#include \"HLS/hls_internal.h\"\012#include \"HLS/task.h\"\012#include \"HLS/lsu.h\"\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_memory_impl(__x)                          __attribute__((__memory__(__x)))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012#define hls_simple_dual_port_memory                   __attribute__((simple_dual_port))\012#define hls_max_replicates(__x)                       __attribute__((max_replicates(__x)))\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012#define hls_scheduler_target_fmax_mhz(__x)     __attribute__((scheduler_target_fmax_mhz(__x)))\012#define hls_component_ii(__x)                  __attribute__((hls_ii(__x)))\012#define hls_disable_component_pipelining       __attribute__((hls_force_loop_pipelining(\"off\")))\012\012// Cluster attributes\012#define hls_use_stall_enable_clusters          __attribute__((stall_enable))\012\012// fpga_reg support\012#define hls_fpga_reg(__x)                      __fpga_reg(__x)\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012#define hls_max_replicates(__x)\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012#define hls_scheduler_target_fmax_mhz(__x)\012#define hls_component_ii(__x)\012#define hls_disable_component_pipelining\012\012#define hls_use_stall_enable_clusters\012\012#define hls_fpga_reg(__x) __x\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012  template<int _N> struct dwidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct awidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct latency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct readwrite_mode {\012    // Should be enum readwrite_t but we don't know how to make GetValue generic\012    static constexpr enum readwrite_t value = (readwrite_t) _N;\012    static constexpr enum readwrite_t defaultValue = readwrite;\012  };\012\012  template<int _N> struct maxburst {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct align {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = -1;\012  };\012\012  template<int _N> struct aspace {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct waitrequest {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template <template <int> class _Type, class _T>\012  struct MatchType : std::is_same<_Type<_T::value>,_T> {};\012\012  template <template <int> class _Type, class ... _T>\012  struct GetValue {\012    // any value is ok here, so '0' is fine for an arbitrary instantiation\012    enum { value = _Type<0>::defaultValue };\012    // only when _T is empty\012  };\012\012  template <template <int> class _Type, class _T1, class ... _T>\012  struct GetValue<_Type, _T1, _T...> {\012    enum { value = std::conditional<MatchType<_Type, _T1>::value, _T1, GetValue<_Type, _T...>>::type::value };\012  };\012\012template <typename _DT, class ... _Params>\012class mm_master final\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false)\012      : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                              _readwrite_mode, true, _maxburst, _align,\012                              _waitrequest, data, size, sizeof(_DT),\012                              use_socket) {\012    mSize = size;\012    mUse_socket = use_socket;\012    if (size > 0 && size % sizeof(_DT) != 0) {\012      __ihc_hls_runtime_error_x86(\012          \"The buffer size must be a multiple of the type size\");\012    }\012  }\012#else\012  template<typename _T> explicit mm_master(_T *data, std::size_t size=0, bool use_socket=false);\012#endif\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // but illegal in a component\012  mm_master(const mm_master &other);\012\012  mm_master& operator=(const mm_master& other);\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master();\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator _T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  _DT &operator[](int index);\012  _DT &operator*();\012  _DT *operator->();\012  template<typename _T> operator _T();\012  _DT *operator+(int index);\012  template<typename _T> _DT *operator&(_T value);\012  template<typename _T> _DT *operator|(_T value);\012  template<typename _T> _DT *operator^(_T value);\012  // This function is only supported in the testbench:\012  mm_master<_DT, _Params...>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012private:\012  std::vector<internal::memory_base* > new_masters;\012#else //Fpga\012\012\012#endif\012private:\012  static constexpr int _dwidth   = GetValue<ihc::dwidth, _Params...>::value;\012  static constexpr int _awidth   = GetValue<ihc::awidth, _Params...>::value;\012  static constexpr int _aspace   = GetValue<ihc::aspace, _Params...>::value;\012  static constexpr int _latency  = GetValue<ihc::latency, _Params...>::value;\012  static constexpr int _maxburst = GetValue<ihc::maxburst, _Params...>::value;\012  static constexpr int _align    = (GetValue<ihc::align, _Params...>::value == -1) ? alignof(_DT) : GetValue<ihc::align, _Params...>::value;\012  static constexpr int _readwrite_mode = GetValue<ihc::readwrite_mode, _Params...>::value;\012  static constexpr bool _waitrequest = GetValue<ihc::waitrequest, _Params...>::value;\012\012  _DT __hls_mm_master_aspace(_aspace) *mPtr;\012  int mSize;\012  bool mUse_socket;\012};\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012  template<int _N> struct buffer {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct readyLatency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct bitsPerSymbol {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct usesPackets {\012    static constexpr bool value = _N;\012    static constexpr bool defaultValue = false;\012  };\012\012  template<int _N> struct usesValid {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesReady {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesEmpty {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template<int _N> struct firstSymbolInHighOrderBits {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012template <typename _T, class ... _Params>\012class stream_in final : public internal::stream<_T, _Params...> {\012public:\012  stream_in();\012  stream_in(const stream_in&) = delete;\012  stream_in(const stream_in&&) = delete;\012  stream_in& operator=(const stream_in&) = delete;\012  stream_in& operator=(const stream_in&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits =  GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012template <typename _T, class ... _Params>\012class stream_out final : public internal::stream<_T, _Params...> {\012\012public:\012  stream_out();\012  stream_out(const stream_out&) = delete;\012  stream_out(const stream_out&&) = delete;\012  stream_out& operator=(const stream_out&) = delete;\012  stream_out& operator=(const stream_out&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012\012// Bi-directional inter-task stream\012template<typename _T, class ... _Params>\012class stream final : public internal::stream<_T, _Params...> {\012public:\012  stream();\012  stream(const stream&) = delete;\012  stream(const stream&&) = delete;\012  stream& operator=(const stream&) = delete;\012  stream& operator=(const stream&&) = delete;\012  _T read(bool wait=true);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=true);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=true);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012\012private:\012  static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012  static_assert(_usesValid, \"Bi-directional stream interfaces must use Valid signal\");\012  static_assert(_usesReady, \"Bi-directional stream interfaces must use Ready signal\");\012\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012#define ihc_hls_set_component_wait_cycle(component_address, num_wait_cycles) \\\012  __ihc_hls_set_component_wait_cycle((void*) (component_address), num_wait_cycles)\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {}\012\012#else\012extern \"C\" void __acl_mem_fence(unsigned int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  __acl_mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // necessary to ensurebut illegal in a component\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::mm_master(const mm_master &other)\012    : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                            static_cast<readwrite_t>(_readwrite_mode), true,\012                            _maxburst, _align, _waitrequest, other.get_base(),\012                            other.get_size(), sizeof(_DT),\012                            other.uses_socket()) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.mUse_socket;\012  mem = other.mem;\012}\012\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>& mm_master<_DT, _Params...>::operator=(const mm_master& other) {\012    mPtr = other.mPtr;\012    mSize = other.mSize;\012    mUse_socket = other.m_Use_socket;\012    mem = other.mem;\012  }\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>::~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params... >::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((_DT*)mem)[index];\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return ((_DT*)mem)[0];\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT*)mem;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)mem);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((_DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename _DT, class ... _Params>\012mm_master<_DT, _Params...>& mm_master<_DT,_Params...>::getInterfaceAtIndex(int index) {\012  assert(mSize==0 || index*data_size<mSize);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<_DT, _Params...> *temp = new mm_master(&(((_DT*)mem)[index]), mSize - index * sizeof(_DT), mUse_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012stream_in<_T,_Params...>::stream_in() {}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  stream_out<_T,_Params...>::stream_out() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_ready, ready_delta);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  stream<_T,_Params...>::stream() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  return *(_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, index);\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT,_Params...>::operator*(){\012  return *(_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT,_Params...>::operator->(){\012  return (_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  return (_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0) + index;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0));\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) ^ (unsigned long long)value);\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0 );\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer,  _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void) wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0 );\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this,  _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, empty );\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012#endif\012} // namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012"}, {"path":"/opt/altera_pro/19.4/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#include <stdio.h>\012#include <stdlib.h>\012#include <mutex>\012#include <condition_variable>\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012#define __hls_mm_master_aspace(__x) __attribute__((address_space(__x + 1024)))\012#else\012#define __hls_mm_master_aspace(__x)\012#endif\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#if defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name, unsigned int wait_cycles);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012extern \"C\" void __ihc_hls_set_component_wait_cycle(const void * component_address, unsigned int num_wait_cycles);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012\012#ifdef HLS_X86\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012#endif\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012// ignore __fpga_reg in emulation flow\012#ifdef HLS_X86\012  #define __fpga_reg(x) (x)\012#elif defined(__clang__)\012#if __has_builtin(__builtin_fpga_reg)\012  #ifndef __fpga_reg\012    #define __fpga_reg __builtin_fpga_reg\012  #endif\012#endif\012#endif\012\012namespace ihc {\012\012namespace internal {\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  size_t sim_base;\012\012protected:\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              int readwrite_mode, bool byteenabled, int maxburst, int align,\012              bool waitrequest, void *mem, size_t size, size_t data_size,\012              bool use_socket)\012      : aspace(aspace), awidth(awidth), dwidth(dwidth), latency(latency),\012        readwrite_mode(static_cast<readwrite_t>(readwrite_mode)),\012        byteenabled(byteenabled), maxburst(maxburst), align(align),\012        waitrequest(waitrequest), data_size(data_size), mem(mem), size(size),\012        use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              readwrite_t readwrite_mode, bool byteenabled, int maxburst,\012              int align, bool waitrequest);\012  // set_parameters, set_base, and get_sim_base are defined in the hls_cosim library\012  void set_parameters(int aspace, int awidth, int dwidth, int latency,\012                      readwrite_t readwrite_mode, bool byteenabled,\012                      int maxburst, int align, bool waitrequest);\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() const {return aspace;}\012  void * get_base() const {return mem;}\012  size_t get_size() const {return size;}\012  int get_awidth() const {return awidth;}\012  int get_dwidth() const {return dwidth;}\012  int get_latency() const {return latency;}\012  readwrite_t get_readwrite_mode() const {return readwrite_mode;}\012  bool get_byteenabled() const {return byteenabled;}\012  int get_maxburst() const {return maxburst;}\012  int get_align() const {return align;}\012  bool get_waitrequest() const {return waitrequest;}\012  \012  size_t get_data_size() const {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base();\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() const {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, class ... Params>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012  std::queue<int> qpe_;\012  std::mutex m_;\012  std::condition_variable cv_;\012#endif\012public:  \012  stream();\012  // do not allow copy and assignment of streams\012  stream(const stream&) = delete;\012  stream& operator=(const stream&) = delete; \012\012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read(bool wait=false);               \012  virtual void write(const T& arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop, bool wait=false);\012  virtual T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  virtual void write(const T& arg, bool sop, bool eop);\012  virtual void write(const T& arg, bool sop, bool eop, int empty);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  virtual bool tryWrite(const T& arg, bool sop, bool eop);     \012  virtual bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(const T& arg);      \012  T tryRead(bool &success); \012  bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  T read(bool& sop, bool& eop, int& empty);\012  void write(const T& arg, bool sop, bool eop);\012  void write(const T& arg, bool sop, bool eop, int empty);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const T& arg, bool sop, bool eop);     \012  bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012   T _internal_cosim_front(bool& sop, bool& eop, int& empty);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void write_by_ptr_pkt_e(void *data, bool* sop, bool*eop, void* empty);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, class ... Params>\012  stream<T,Params...>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, class ... Params>\012bool stream<T,Params...>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012 \012    // unused sideband signals\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    empty = qpe_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, bool wait) {\012  T arg;\012\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  // unused sideband signal\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty_ && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front() {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop, int& empty) {\012  T arg;      \012\012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop, int empty) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop, empty);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(false,false));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop, int empty) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(empty);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = read(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = _internal_cosim_front(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    T elem;\012    int temp_empty;\012    memcpy(&elem, data, sizeof(T));\012    memcpy(&temp_empty, empty, sizeof(int));\012    write(elem, *sop, *eop, temp_empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012bool stream<T, Params...>::stall() {\012  if (m_remaining_period == 0) {\012    setStallPeriod();\012  }\012  m_remaining_period--;\012  if (m_remaining_period < m_period_threshold) { \012    return false;\012  } else {\012    return true;\012  }\012}\012\012template<typename T, class ... Params>\012unsigned stream<T, Params...>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012\012"}, {"path":"/opt/altera_pro/19.4/hls/include/HLS/lsu.h", "name":"lsu.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/lsu.h", "content":"/**************************************************************************\012 *                                                                        *\012 *  A library that allows controlling the LSU of a given load/store site  *\012 *  Copyright 2019, Intel Corporation                                     *\012 *  All Rights Reserved.                                                  *\012 *                                                                        *\012 *  Author: Mohammad Fawaz                                                *\012 *                                                                        *\012 **************************************************************************/\012\012#ifndef __HLS_LSU_H__\012#define __HLS_LSU_H__\012\012namespace ihc {\012// Forward declarations. These are defined in HLS/hls.h\012template <typename _DT, class... _Params> class mm_master;\012template <template <int> class _Type, class... _T> struct GetValue;\012\012enum style_t {\012  BURST_COALESCED = 0,\012  PIPELINED,\012};\012\012template <int _N> struct style {\012  static constexpr enum style_t value = (style_t)_N;\012  static constexpr enum style_t defaultValue = BURST_COALESCED;\012};\012\012template <int _N> struct static_coalescing {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <class... _LSUParams> class lsu final {\012public:\012  lsu() = delete;\012\012#ifdef HLS_X86\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    return *Ptr;\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) { return *Ptr; }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    *Ptr = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) { *Ptr = Val; }\012#else\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(&*Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                               _static_coalescing);\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                               _static_coalescing);\012  }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(&*Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012#endif\012\012private:\012  static constexpr int _style = GetValue<ihc::style, _LSUParams...>::value;\012  static constexpr int _static_coalescing =\012      GetValue<ihc::static_coalescing, _LSUParams...>::value;\012\012  static void CheckLoad() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED,\012                  \"Invalid LSU style choice for a load operation\");\012  }\012  static void CheckStore() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED,\012                  \"Invalid LSU style choice for a store operation\");\012  }\012};\012} // namespace ihc\012\012#endif //__HLS_LSU_H__\012"}, {"path":"/opt/altera_pro/19.4/hls/include/HLS/task.h", "name":"task.h", "has_active_debug_locs":false, "absName":"/opt/altera_pro/19.4/hls/include/HLS/task.h", "content":"#ifndef _INTEL_IHC_HLS_TASK\012#define _INTEL_IHC_HLS_TASK\012#include \"HLS/function_traits.h\"\012\012#include <type_traits>\012#include <utility>\012\012// Make sure the macros to take the user calls into implementations\012// is not in effect for the source code of the implementation\012#undef launch\012#undef collect\012\012// Bring in the platform specific '_task' for composition\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012#include \"HLS/internal/_task_FPGA.h\"\012#else\012#include \"HLS/internal/_task_X64.h\"\012#endif\012\012namespace ihc {\012  namespace internal {\012    // Signature for void func()\012    using VoidFuncTy = void ();\012\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Launch the calculations\012    //   task<function>::launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    //\012    // The task is implemented as an\012    // Adaptor Design Pattern\012    // The X64 or FPGA implementation is adapted to the desired API\012    // This adaptor is straight forward:\012    // Both architecture specific implementations are supposed to\012    // be interface compatible with this adaptor\012    template<typename X, X& f, bool detach = false>\012    class task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Launch the callable\012      template<int capacity, typename ... Args>\012      static void launch(Args&& ... args) {\012        _t.template launch<capacity>(std::forward<Args>(args)...);\012      }\012\012      // Get the result\012      template<int capacity>\012      static T collect() {\012        // Restore void if needed\012        return static_cast<T>(_t.template collect<capacity>());\012      }\012\012    private:\012      // Constructor\012      task() {};\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      // Composition (_task is architecture specific)\012      // Singleton\012      // Anywhere in the function hierarchy where \"f\" gets called,\012      // this specific task (with the corresponding thread and queue)\012      // needs to be used\012      static internal::_task<X, f, detach> _t;\012    }; // class task\012\012    template <typename X, X& f, bool detach>\012    internal::_task<X, f, detach> task<X, f, detach>::_t;\012\012    // Launch (through singleton)\012    template <int capacity, class X, X &f, typename... Args>\012    void launch(Args &&... args) {\012      task<X, f>::template launch<capacity>(std::forward<Args>(args)...);\012    }\012\012    // Collect (through singleton)\012    template<int capacity, typename X, X& f>\012    typename ihc::function_traits<decltype(f)>::return_type collect() {\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012      // Restore void if needed\012      return static_cast<T>(task<X, f>::template collect<capacity>());\012    }\012\012    // launch_always_run_helper utilities\012    template <VoidFuncTy &f> void launch_at_startup() {\012      while (1) {\012        f();\012      }\012    }\012\012    template <VoidFuncTy &f> class launch_always_run_helper {\012    public:\012      launch_always_run_helper() {\012        task<VoidFuncTy, launch_at_startup<f>, true>::template launch<0>();\012      }\012    };\012  } // namespace internal\012\012  /// Launches a task function at when the component starts up.\012  /// The task function to be launched must take no input arguments and have\012  /// a void return.\012  template <internal::VoidFuncTy &f> void launch_always_run() {\012    static internal::launch_always_run_helper<f> t;\012  }\012\012  // Fake functions to help with Content Assist (IntelliSense)\012\012  // /!\\ Please remember to put parentheses around a launch of\012  //     a templated function:\012  //     ihc::launch(\012  //       ( foo<Types...> ),\012  //       args... );\012  template<int capacity, typename F, typename... Args>\012  void launch(F&& f, Args&&...args);\012  template<int capacity, typename F>\012  typename ihc::function_traits<F>::return_type collect(F&& f);\012\012} // namespace ihc\012\012// Work around for C++14 (no support for <auto& f>\012#define launch(x, ...)  internal::launch <0, decltype(x), x>(__VA_ARGS__)\012#define buffered_launch(depth, x, ...)  internal::launch <depth, decltype(x), x>(__VA_ARGS__)\012\012#define collect(x)      internal::collect<0, decltype(x), x>()\012#define buffered_collect(depth, x)      internal::collect<depth, decltype(x), x>()\012\012#endif // _INTEL_IHC_HLS_TASK\012"}];