// (C) 1992-2019 Intel Corporation.                            
// Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack words    
// and logos are trademarks of Intel Corporation or its subsidiaries in the U.S.  
// and/or other countries. Other marks and brands may be claimed as the property  
// of others. See Trademarks on intel.com for full list of Intel trademarks or    
// the Trademarks & Brands Names Database (if Intel) or See www.Intel.com/legal (if Altera) 
// Your use of Intel Corporation's design tools, logic functions and other        
// software and tools, and its AMPP partner logic functions, and any output       
// files any of the foregoing (including device programming or simulation         
// files), and any associated documentation or information are expressly subject  
// to the terms and conditions of the Altera Program License Subscription         
// Agreement, Intel MegaCore Function License Agreement, or other applicable      
// license agreement, including, without limitation, that your use is for the     
// sole purpose of programming logic devices manufactured by Intel and sold by    
// Intel or its authorized distributors.  Please refer to the applicable          
// agreement for further details.                                                 

// Generated by Intel(R) HLS Compiler, Version 19.4.0 Build 64

/////////////////////////////////////////////////////////////////
// MODULE obs_key_to_virtual_key_internal
/////////////////////////////////////////////////////////////////
module obs_key_to_virtual_key_internal
(
   input logic clock,
   input logic resetn,
   input logic [31:0] code,
   input logic [63:0] INVALID_KEY,
   input logic [63:0] kVK_ANSI_0,
   input logic [63:0] kVK_ANSI_1,
   input logic [63:0] kVK_ANSI_2,
   input logic [63:0] kVK_ANSI_3,
   input logic [63:0] kVK_ANSI_4,
   input logic [63:0] kVK_ANSI_5,
   input logic [63:0] kVK_ANSI_6,
   input logic [63:0] kVK_ANSI_7,
   input logic [63:0] kVK_ANSI_8,
   input logic [63:0] kVK_ANSI_9,
   input logic [63:0] kVK_ANSI_A,
   input logic [63:0] kVK_ANSI_B,
   input logic [63:0] kVK_ANSI_Backslash,
   input logic [63:0] kVK_ANSI_C,
   input logic [63:0] kVK_ANSI_Comma,
   input logic [63:0] kVK_ANSI_D,
   input logic [63:0] kVK_ANSI_E,
   input logic [63:0] kVK_ANSI_Equal,
   input logic [63:0] kVK_ANSI_F,
   input logic [63:0] kVK_ANSI_G,
   input logic [63:0] kVK_ANSI_Grave,
   input logic [63:0] kVK_ANSI_H,
   input logic [63:0] kVK_ANSI_I,
   input logic [63:0] kVK_ANSI_J,
   input logic [63:0] kVK_ANSI_K,
   input logic [63:0] kVK_ANSI_Keypad0,
   input logic [63:0] kVK_ANSI_Keypad1,
   input logic [63:0] kVK_ANSI_Keypad2,
   input logic [63:0] kVK_ANSI_Keypad3,
   input logic [63:0] kVK_ANSI_Keypad4,
   input logic [63:0] kVK_ANSI_Keypad5,
   input logic [63:0] kVK_ANSI_Keypad6,
   input logic [63:0] kVK_ANSI_Keypad7,
   input logic [63:0] kVK_ANSI_Keypad8,
   input logic [63:0] kVK_ANSI_Keypad9,
   input logic [63:0] kVK_ANSI_KeypadClear,
   input logic [63:0] kVK_ANSI_KeypadDecimal,
   input logic [63:0] kVK_ANSI_KeypadDivide,
   input logic [63:0] kVK_ANSI_KeypadEnter,
   input logic [63:0] kVK_ANSI_KeypadEquals,
   input logic [63:0] kVK_ANSI_KeypadMinus,
   input logic [63:0] kVK_ANSI_KeypadMultiply,
   input logic [63:0] kVK_ANSI_KeypadPlus,
   input logic [63:0] kVK_ANSI_L,
   input logic [63:0] kVK_ANSI_LeftBracket,
   input logic [63:0] kVK_ANSI_M,
   input logic [63:0] kVK_ANSI_Minus,
   input logic [63:0] kVK_ANSI_N,
   input logic [63:0] kVK_ANSI_O,
   input logic [63:0] kVK_ANSI_P,
   input logic [63:0] kVK_ANSI_Period,
   input logic [63:0] kVK_ANSI_Q,
   input logic [63:0] kVK_ANSI_Quote,
   input logic [63:0] kVK_ANSI_R,
   input logic [63:0] kVK_ANSI_RightBracket,
   input logic [63:0] kVK_ANSI_S,
   input logic [63:0] kVK_ANSI_Semicolon,
   input logic [63:0] kVK_ANSI_Slash,
   input logic [63:0] kVK_ANSI_T,
   input logic [63:0] kVK_ANSI_U,
   input logic [63:0] kVK_ANSI_V,
   input logic [63:0] kVK_ANSI_W,
   input logic [63:0] kVK_ANSI_X,
   input logic [63:0] kVK_ANSI_Y,
   input logic [63:0] kVK_ANSI_Z,
   input logic [63:0] kVK_CapsLock,
   input logic [63:0] kVK_Command,
   input logic [63:0] kVK_Control,
   input logic [63:0] kVK_Delete,
   input logic [63:0] kVK_DownArrow,
   input logic [63:0] kVK_End,
   input logic [63:0] kVK_Escape,
   input logic [63:0] kVK_F1,
   input logic [63:0] kVK_F10,
   input logic [63:0] kVK_F11,
   input logic [63:0] kVK_F12,
   input logic [63:0] kVK_F13,
   input logic [63:0] kVK_F14,
   input logic [63:0] kVK_F15,
   input logic [63:0] kVK_F16,
   input logic [63:0] kVK_F17,
   input logic [63:0] kVK_F18,
   input logic [63:0] kVK_F19,
   input logic [63:0] kVK_F2,
   input logic [63:0] kVK_F20,
   input logic [63:0] kVK_F3,
   input logic [63:0] kVK_F4,
   input logic [63:0] kVK_F5,
   input logic [63:0] kVK_F6,
   input logic [63:0] kVK_F7,
   input logic [63:0] kVK_F8,
   input logic [63:0] kVK_F9,
   input logic [63:0] kVK_ForwardDelete,
   input logic [63:0] kVK_Help,
   input logic [63:0] kVK_Home,
   input logic [63:0] kVK_ISO_Section,
   input logic [63:0] kVK_LeftArrow,
   input logic [63:0] kVK_Option,
   input logic [63:0] kVK_PageDown,
   input logic [63:0] kVK_PageUp,
   input logic [63:0] kVK_Return,
   input logic [63:0] kVK_RightArrow,
   input logic [63:0] kVK_Shift,
   input logic [63:0] kVK_Space,
   input logic [63:0] kVK_Tab,
   input logic [63:0] kVK_UpArrow,
   input logic start,
   output logic busy,
   output logic done,
   input logic stall,
   output logic [31:0] returndata,
   // AVM avmm_0_rw
   output logic avmm_0_rw_enable,
   output logic avmm_0_rw_read,
   output logic avmm_0_rw_write,
   output logic [63:0] avmm_0_rw_address,
   output logic [63:0] avmm_0_rw_writedata,
   output logic [7:0] avmm_0_rw_byteenable,
   input logic [63:0] avmm_0_rw_readdata,
   input logic avmm_0_rw_readdatavalid,
   output logic avmm_0_rw_burstcount,
   input logic avmm_0_rw_writeack
);
   genvar __i;
   logic avmm_0_global_avm_enable [1];
   logic avmm_0_global_avm_read [1];
   logic avmm_0_global_avm_write [1];
   logic [63:0] avmm_0_global_avm_address [1];
   logic [63:0] avmm_0_global_avm_writedata [1];
   logic [7:0] avmm_0_global_avm_byteenable [1];
   logic avmm_0_global_avm_waitrequest [1];
   logic [63:0] avmm_0_global_avm_readdata [1];
   logic avmm_0_global_avm_readdatavalid [1];
   logic avmm_0_global_avm_burstcount [1];
   logic avmm_0_global_avm_writeack [1];

   // INST obs_key_to_virtual_key_internal of obs_key_to_virtual_key_function_wrapper
   obs_key_to_virtual_key_function_wrapper obs_key_to_virtual_key_internal
   (
      .clock(clock),
      .resetn(resetn),
      .code(code),
      .INVALID_KEY(INVALID_KEY),
      .kVK_ANSI_0(kVK_ANSI_0),
      .kVK_ANSI_1(kVK_ANSI_1),
      .kVK_ANSI_2(kVK_ANSI_2),
      .kVK_ANSI_3(kVK_ANSI_3),
      .kVK_ANSI_4(kVK_ANSI_4),
      .kVK_ANSI_5(kVK_ANSI_5),
      .kVK_ANSI_6(kVK_ANSI_6),
      .kVK_ANSI_7(kVK_ANSI_7),
      .kVK_ANSI_8(kVK_ANSI_8),
      .kVK_ANSI_9(kVK_ANSI_9),
      .kVK_ANSI_A(kVK_ANSI_A),
      .kVK_ANSI_B(kVK_ANSI_B),
      .kVK_ANSI_Backslash(kVK_ANSI_Backslash),
      .kVK_ANSI_C(kVK_ANSI_C),
      .kVK_ANSI_Comma(kVK_ANSI_Comma),
      .kVK_ANSI_D(kVK_ANSI_D),
      .kVK_ANSI_E(kVK_ANSI_E),
      .kVK_ANSI_Equal(kVK_ANSI_Equal),
      .kVK_ANSI_F(kVK_ANSI_F),
      .kVK_ANSI_G(kVK_ANSI_G),
      .kVK_ANSI_Grave(kVK_ANSI_Grave),
      .kVK_ANSI_H(kVK_ANSI_H),
      .kVK_ANSI_I(kVK_ANSI_I),
      .kVK_ANSI_J(kVK_ANSI_J),
      .kVK_ANSI_K(kVK_ANSI_K),
      .kVK_ANSI_Keypad0(kVK_ANSI_Keypad0),
      .kVK_ANSI_Keypad1(kVK_ANSI_Keypad1),
      .kVK_ANSI_Keypad2(kVK_ANSI_Keypad2),
      .kVK_ANSI_Keypad3(kVK_ANSI_Keypad3),
      .kVK_ANSI_Keypad4(kVK_ANSI_Keypad4),
      .kVK_ANSI_Keypad5(kVK_ANSI_Keypad5),
      .kVK_ANSI_Keypad6(kVK_ANSI_Keypad6),
      .kVK_ANSI_Keypad7(kVK_ANSI_Keypad7),
      .kVK_ANSI_Keypad8(kVK_ANSI_Keypad8),
      .kVK_ANSI_Keypad9(kVK_ANSI_Keypad9),
      .kVK_ANSI_KeypadClear(kVK_ANSI_KeypadClear),
      .kVK_ANSI_KeypadDecimal(kVK_ANSI_KeypadDecimal),
      .kVK_ANSI_KeypadDivide(kVK_ANSI_KeypadDivide),
      .kVK_ANSI_KeypadEnter(kVK_ANSI_KeypadEnter),
      .kVK_ANSI_KeypadEquals(kVK_ANSI_KeypadEquals),
      .kVK_ANSI_KeypadMinus(kVK_ANSI_KeypadMinus),
      .kVK_ANSI_KeypadMultiply(kVK_ANSI_KeypadMultiply),
      .kVK_ANSI_KeypadPlus(kVK_ANSI_KeypadPlus),
      .kVK_ANSI_L(kVK_ANSI_L),
      .kVK_ANSI_LeftBracket(kVK_ANSI_LeftBracket),
      .kVK_ANSI_M(kVK_ANSI_M),
      .kVK_ANSI_Minus(kVK_ANSI_Minus),
      .kVK_ANSI_N(kVK_ANSI_N),
      .kVK_ANSI_O(kVK_ANSI_O),
      .kVK_ANSI_P(kVK_ANSI_P),
      .kVK_ANSI_Period(kVK_ANSI_Period),
      .kVK_ANSI_Q(kVK_ANSI_Q),
      .kVK_ANSI_Quote(kVK_ANSI_Quote),
      .kVK_ANSI_R(kVK_ANSI_R),
      .kVK_ANSI_RightBracket(kVK_ANSI_RightBracket),
      .kVK_ANSI_S(kVK_ANSI_S),
      .kVK_ANSI_Semicolon(kVK_ANSI_Semicolon),
      .kVK_ANSI_Slash(kVK_ANSI_Slash),
      .kVK_ANSI_T(kVK_ANSI_T),
      .kVK_ANSI_U(kVK_ANSI_U),
      .kVK_ANSI_V(kVK_ANSI_V),
      .kVK_ANSI_W(kVK_ANSI_W),
      .kVK_ANSI_X(kVK_ANSI_X),
      .kVK_ANSI_Y(kVK_ANSI_Y),
      .kVK_ANSI_Z(kVK_ANSI_Z),
      .kVK_CapsLock(kVK_CapsLock),
      .kVK_Command(kVK_Command),
      .kVK_Control(kVK_Control),
      .kVK_Delete(kVK_Delete),
      .kVK_DownArrow(kVK_DownArrow),
      .kVK_End(kVK_End),
      .kVK_Escape(kVK_Escape),
      .kVK_F1(kVK_F1),
      .kVK_F10(kVK_F10),
      .kVK_F11(kVK_F11),
      .kVK_F12(kVK_F12),
      .kVK_F13(kVK_F13),
      .kVK_F14(kVK_F14),
      .kVK_F15(kVK_F15),
      .kVK_F16(kVK_F16),
      .kVK_F17(kVK_F17),
      .kVK_F18(kVK_F18),
      .kVK_F19(kVK_F19),
      .kVK_F2(kVK_F2),
      .kVK_F20(kVK_F20),
      .kVK_F3(kVK_F3),
      .kVK_F4(kVK_F4),
      .kVK_F5(kVK_F5),
      .kVK_F6(kVK_F6),
      .kVK_F7(kVK_F7),
      .kVK_F8(kVK_F8),
      .kVK_F9(kVK_F9),
      .kVK_ForwardDelete(kVK_ForwardDelete),
      .kVK_Help(kVK_Help),
      .kVK_Home(kVK_Home),
      .kVK_ISO_Section(kVK_ISO_Section),
      .kVK_LeftArrow(kVK_LeftArrow),
      .kVK_Option(kVK_Option),
      .kVK_PageDown(kVK_PageDown),
      .kVK_PageUp(kVK_PageUp),
      .kVK_Return(kVK_Return),
      .kVK_RightArrow(kVK_RightArrow),
      .kVK_Shift(kVK_Shift),
      .kVK_Space(kVK_Space),
      .kVK_Tab(kVK_Tab),
      .kVK_UpArrow(kVK_UpArrow),
      .start(start),
      .busy(busy),
      .done(done),
      .stall(stall),
      .returndata(returndata),
      // AVM avm_retval_01_obs_key_to_virtual_key
      .avm_retval_01_obs_key_to_virtual_key_enable(avmm_0_global_avm_enable[0]),
      .avm_retval_01_obs_key_to_virtual_key_read(avmm_0_global_avm_read[0]),
      .avm_retval_01_obs_key_to_virtual_key_write(avmm_0_global_avm_write[0]),
      .avm_retval_01_obs_key_to_virtual_key_address(avmm_0_global_avm_address[0]),
      .avm_retval_01_obs_key_to_virtual_key_writedata(avmm_0_global_avm_writedata[0]),
      .avm_retval_01_obs_key_to_virtual_key_byteenable(avmm_0_global_avm_byteenable[0]),
      .avm_retval_01_obs_key_to_virtual_key_waitrequest(avmm_0_global_avm_waitrequest[0]),
      .avm_retval_01_obs_key_to_virtual_key_readdata(avmm_0_global_avm_readdata[0]),
      .avm_retval_01_obs_key_to_virtual_key_readdatavalid(avmm_0_global_avm_readdatavalid[0]),
      .avm_retval_01_obs_key_to_virtual_key_burstcount(avmm_0_global_avm_burstcount[0]),
      .avm_retval_01_obs_key_to_virtual_key_writeack(avmm_0_global_avm_writeack[0])
   );

   generate
   begin:avmm_0_
      logic avmm_0_icm_in_arb_request [1];
      logic avmm_0_icm_in_arb_enable [1];
      logic avmm_0_icm_in_arb_read [1];
      logic avmm_0_icm_in_arb_write [1];
      logic avmm_0_icm_in_arb_burstcount [1];
      logic [60:0] avmm_0_icm_in_arb_address [1];
      logic [63:0] avmm_0_icm_in_arb_writedata [1];
      logic [7:0] avmm_0_icm_in_arb_byteenable [1];
      logic avmm_0_icm_in_arb_stall [1];
      logic avmm_0_icm_in_wrp_ack [1];
      logic avmm_0_icm_in_rrp_datavalid [1];
      logic [63:0] avmm_0_icm_in_rrp_data [1];
      logic icm_out_0_rw_arb_request [1];
      logic icm_out_0_rw_arb_enable [1];
      logic icm_out_0_rw_arb_read [1];
      logic icm_out_0_rw_arb_write [1];
      logic icm_out_0_rw_arb_burstcount [1];
      logic [60:0] icm_out_0_rw_arb_address [1];
      logic [63:0] icm_out_0_rw_arb_writedata [1];
      logic [7:0] icm_out_0_rw_arb_byteenable [1];
      logic icm_out_0_rw_arb_id [1];
      logic icm_out_0_rw_arb_stall [1];
      logic icm_out_0_rw_wrp_ack [1];
      logic icm_out_0_rw_rrp_datavalid [1];
      logic [63:0] icm_out_0_rw_rrp_data [1];
      logic icm_routedavmm_0_rw_arb_request [1];
      logic icm_routedavmm_0_rw_arb_enable [1];
      logic icm_routedavmm_0_rw_arb_read [1];
      logic icm_routedavmm_0_rw_arb_write [1];
      logic icm_routedavmm_0_rw_arb_burstcount [1];
      logic [60:0] icm_routedavmm_0_rw_arb_address [1];
      logic [63:0] icm_routedavmm_0_rw_arb_writedata [1];
      logic [7:0] icm_routedavmm_0_rw_arb_byteenable [1];
      logic icm_routedavmm_0_rw_arb_stall [1];
      logic icm_routedavmm_0_rw_wrp_ack [1];
      logic icm_routedavmm_0_rw_rrp_datavalid [1];
      logic [63:0] icm_routedavmm_0_rw_rrp_data [1];

      for( __i = 0; __i < 1; __i = __i + 1 )
      begin:t
         // INST avmm_0_avm_to_ic of acl_avm_to_ic
         acl_avm_to_ic
         #(
            .DATA_W(64),
            .WRITEDATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(64),
            .BYTEENA_W(8)
         )
         avmm_0_avm_to_ic
         (
            // AVM avm
            .avm_enable(avmm_0_global_avm_enable[__i]),
            .avm_read(avmm_0_global_avm_read[__i]),
            .avm_write(avmm_0_global_avm_write[__i]),
            .avm_address(avmm_0_global_avm_address[__i]),
            .avm_writedata(avmm_0_global_avm_writedata[__i]),
            .avm_byteenable(avmm_0_global_avm_byteenable[__i]),
            .avm_waitrequest(avmm_0_global_avm_waitrequest[__i]),
            .avm_readdata(avmm_0_global_avm_readdata[__i]),
            .avm_readdatavalid(avmm_0_global_avm_readdatavalid[__i]),
            .avm_burstcount(avmm_0_global_avm_burstcount[__i]),
            .avm_writeack(avmm_0_global_avm_writeack[__i]),
            // ICM ic
            .ic_arb_request(avmm_0_icm_in_arb_request[__i]),
            .ic_arb_enable(avmm_0_icm_in_arb_enable[__i]),
            .ic_arb_read(avmm_0_icm_in_arb_read[__i]),
            .ic_arb_write(avmm_0_icm_in_arb_write[__i]),
            .ic_arb_burstcount(avmm_0_icm_in_arb_burstcount[__i]),
            .ic_arb_address(avmm_0_icm_in_arb_address[__i]),
            .ic_arb_writedata(avmm_0_icm_in_arb_writedata[__i]),
            .ic_arb_byteenable(avmm_0_icm_in_arb_byteenable[__i]),
            .ic_arb_stall(avmm_0_icm_in_arb_stall[__i]),
            .ic_wrp_ack(avmm_0_icm_in_wrp_ack[__i]),
            .ic_rrp_datavalid(avmm_0_icm_in_rrp_datavalid[__i]),
            .ic_rrp_data(avmm_0_icm_in_rrp_data[__i])
         );

      end

      // INST global_icavmm_0_rw of obs_key_to_virtual_key_internal_ic_11797103729985604047
      obs_key_to_virtual_key_internal_ic_11797103729985604047 global_icavmm_0_rw
      (
         .clock(clock),
         .resetn(resetn),
         // ICM m
         .m_arb_request(icm_routedavmm_0_rw_arb_request),
         .m_arb_enable(icm_routedavmm_0_rw_arb_enable),
         .m_arb_read(icm_routedavmm_0_rw_arb_read),
         .m_arb_write(icm_routedavmm_0_rw_arb_write),
         .m_arb_burstcount(icm_routedavmm_0_rw_arb_burstcount),
         .m_arb_address(icm_routedavmm_0_rw_arb_address),
         .m_arb_writedata(icm_routedavmm_0_rw_arb_writedata),
         .m_arb_byteenable(icm_routedavmm_0_rw_arb_byteenable),
         .m_arb_stall(icm_routedavmm_0_rw_arb_stall),
         .m_wrp_ack(icm_routedavmm_0_rw_wrp_ack),
         .m_rrp_datavalid(icm_routedavmm_0_rw_rrp_datavalid),
         .m_rrp_data(icm_routedavmm_0_rw_rrp_data),
         // ICM mout
         .mout_arb_request(icm_out_0_rw_arb_request[0]),
         .mout_arb_enable(icm_out_0_rw_arb_enable[0]),
         .mout_arb_read(icm_out_0_rw_arb_read[0]),
         .mout_arb_write(icm_out_0_rw_arb_write[0]),
         .mout_arb_burstcount(icm_out_0_rw_arb_burstcount[0]),
         .mout_arb_address(icm_out_0_rw_arb_address[0]),
         .mout_arb_writedata(icm_out_0_rw_arb_writedata[0]),
         .mout_arb_byteenable(icm_out_0_rw_arb_byteenable[0]),
         .mout_arb_id(icm_out_0_rw_arb_id[0]),
         .mout_arb_stall(icm_out_0_rw_arb_stall[0]),
         .mout_wrp_ack(icm_out_0_rw_wrp_ack[0]),
         .mout_rrp_datavalid(icm_out_0_rw_rrp_datavalid[0]),
         .mout_rrp_data(icm_out_0_rw_rrp_data[0])
      );

      for( __i = 0; __i < 1; __i = __i + 1 )
      begin:mavmm_0_rw
         assign icm_routedavmm_0_rw_arb_request[__i] = avmm_0_icm_in_arb_request[__i];
         assign icm_routedavmm_0_rw_arb_enable[__i] = avmm_0_icm_in_arb_enable[__i];
         assign icm_routedavmm_0_rw_arb_read[__i] = avmm_0_icm_in_arb_read[__i];
         assign icm_routedavmm_0_rw_arb_write[__i] = avmm_0_icm_in_arb_write[__i];
         assign icm_routedavmm_0_rw_arb_burstcount[__i] = avmm_0_icm_in_arb_burstcount[__i];
         assign icm_routedavmm_0_rw_arb_address[__i] = avmm_0_icm_in_arb_address[__i];
         assign icm_routedavmm_0_rw_arb_writedata[__i] = avmm_0_icm_in_arb_writedata[__i];
         assign icm_routedavmm_0_rw_arb_byteenable[__i] = avmm_0_icm_in_arb_byteenable[__i];
         assign avmm_0_icm_in_arb_stall[__i] = icm_routedavmm_0_rw_arb_stall[__i];
         assign avmm_0_icm_in_wrp_ack[__i] = icm_routedavmm_0_rw_wrp_ack[__i];
         assign avmm_0_icm_in_rrp_datavalid[__i] = icm_routedavmm_0_rw_rrp_datavalid[__i];
         assign avmm_0_icm_in_rrp_data[__i] = icm_routedavmm_0_rw_rrp_data[__i];
      end

      // INST global_out_ic_to_avmavmm_0_rw of acl_ic_to_avm
      acl_ic_to_avm
      #(
         .DATA_W(64),
         .BURSTCOUNT_W(1),
         .ADDRESS_W(64),
         .BYTEENA_W(8),
         .LATENCY(1),
         .USE_WRITE_ACK(0),
         .NO_IDLE_STALL(0),
         .ENABLE_WAITREQUEST_ALLOWANCE(0),
         .ID_W(1),
         .ASYNC_RESET(1),
         .SYNCHRONIZE_RESET(0)
      )
      global_out_ic_to_avmavmm_0_rw
      (
         // ICM ic
         .ic_arb_request(icm_out_0_rw_arb_request[0]),
         .ic_arb_enable(icm_out_0_rw_arb_enable[0]),
         .ic_arb_read(icm_out_0_rw_arb_read[0]),
         .ic_arb_write(icm_out_0_rw_arb_write[0]),
         .ic_arb_burstcount(icm_out_0_rw_arb_burstcount[0]),
         .ic_arb_address(icm_out_0_rw_arb_address[0]),
         .ic_arb_writedata(icm_out_0_rw_arb_writedata[0]),
         .ic_arb_byteenable(icm_out_0_rw_arb_byteenable[0]),
         .ic_arb_id(icm_out_0_rw_arb_id[0]),
         .ic_arb_stall(icm_out_0_rw_arb_stall[0]),
         .ic_wrp_ack(icm_out_0_rw_wrp_ack[0]),
         .ic_rrp_datavalid(icm_out_0_rw_rrp_datavalid[0]),
         .ic_rrp_data(icm_out_0_rw_rrp_data[0]),
         // AVM avm
         .avm_enable(avmm_0_rw_enable),
         .avm_read(avmm_0_rw_read),
         .avm_write(avmm_0_rw_write),
         .avm_address(avmm_0_rw_address),
         .avm_writedata(avmm_0_rw_writedata),
         .avm_byteenable(avmm_0_rw_byteenable),
         .avm_readdata(avmm_0_rw_readdata),
         .avm_readdatavalid(avmm_0_rw_readdatavalid),
         .avm_burstcount(avmm_0_rw_burstcount),
         .avm_writeack(avmm_0_rw_writeack),
         .clock(clock),
         .resetn(resetn),
         .avm_waitrequest(1'b0)
      );

   end
   endgenerate

endmodule

/////////////////////////////////////////////////////////////////
// MODULE obs_key_to_virtual_key_internal_ic_11797103729985604047
/////////////////////////////////////////////////////////////////
module obs_key_to_virtual_key_internal_ic_11797103729985604047
(
   input logic clock,
   input logic resetn,
   // ICM m
   input logic m_arb_request [1],
   input logic m_arb_enable [1],
   input logic m_arb_read [1],
   input logic m_arb_write [1],
   input logic m_arb_burstcount [1],
   input logic [60:0] m_arb_address [1],
   input logic [63:0] m_arb_writedata [1],
   input logic [7:0] m_arb_byteenable [1],
   output logic m_arb_stall [1],
   output logic m_wrp_ack [1],
   output logic m_rrp_datavalid [1],
   output logic [63:0] m_rrp_data [1],
   // ICM mout
   output logic mout_arb_request,
   output logic mout_arb_enable,
   output logic mout_arb_read,
   output logic mout_arb_write,
   output logic mout_arb_burstcount,
   output logic [60:0] mout_arb_address,
   output logic [63:0] mout_arb_writedata,
   output logic [7:0] mout_arb_byteenable,
   output logic mout_arb_id,
   input logic mout_arb_stall,
   input logic mout_wrp_ack,
   input logic mout_rrp_datavalid,
   input logic [63:0] mout_rrp_data
);
   genvar __i;
   generate
      for( __i = 0; __i < 1; __i = __i + 1 )
      begin:m
         logic id;
         acl_ic_master_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) m_intf();
         acl_arb_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) arb_intf();
         acl_ic_wrp_intf
         #(
            .ID_W(1)
         ) wrp_intf();
         acl_ic_rrp_intf
         #(
            .DATA_W(64),
            .ID_W(1)
         ) rrp_intf();

         assign id = __i;
         // INST m_endp of acl_ic_master_endpoint
         acl_ic_master_endpoint
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1),
            .NUM_READ_MASTERS(1),
            .NUM_WRITE_MASTERS(1),
            .ID(__i)
         )
         m_endp
         (
            .clock(clock),
            .resetn(resetn),
            .m_intf(m_intf),
            .arb_intf(arb_intf),
            .wrp_intf(wrp_intf),
            .rrp_intf(rrp_intf)
         );

         assign m_intf.arb.req.request = m_arb_request[__i];
         assign m_intf.arb.req.enable = m_arb_enable[__i];
         assign m_intf.arb.req.read = m_arb_read[__i];
         assign m_intf.arb.req.write = m_arb_write[__i];
         assign m_intf.arb.req.burstcount = m_arb_burstcount[__i];
         assign m_intf.arb.req.address = m_arb_address[__i];
         assign m_intf.arb.req.writedata = m_arb_writedata[__i];
         assign m_intf.arb.req.byteenable = m_arb_byteenable[__i];
         assign m_arb_stall[__i] = m_intf.arb.stall;
         assign m_wrp_ack[__i] = m_intf.wrp.ack;
         assign m_rrp_datavalid[__i] = m_intf.rrp.datavalid;
         assign m_rrp_data[__i] = m_intf.rrp.data;
         assign m_intf.arb.req.id = id;
      end

   endgenerate

   generate
   begin:s
      acl_arb_intf
      #(
         .DATA_W(64),
         .BURSTCOUNT_W(1),
         .ADDRESS_W(61),
         .BYTEENA_W(8),
         .ID_W(1)
      ) in_arb_intf();
      acl_arb_intf
      #(
         .DATA_W(64),
         .BURSTCOUNT_W(1),
         .ADDRESS_W(61),
         .BYTEENA_W(8),
         .ID_W(1)
      ) out_arb_intf();
      acl_ic_wrp_intf
      #(
         .ID_W(1)
      ) wrp_intf();
      acl_ic_rrp_intf
      #(
         .DATA_W(64),
         .ID_W(1)
      ) rrp_intf();

      // INST s_endp of acl_ic_slave_endpoint
      acl_ic_slave_endpoint
      #(
         .DATA_W(64),
         .BURSTCOUNT_W(1),
         .ADDRESS_W(61),
         .BYTEENA_W(8),
         .ID_W(1),
         .NUM_READ_MASTERS(1),
         .NUM_WRITE_MASTERS(1),
         .PIPELINE_RETURN_PATHS(1),
         .WRP_FIFO_DEPTH(0),
         .RRP_FIFO_DEPTH(64),
         .RRP_USE_LL_FIFO(1),
         .SLAVE_FIXED_LATENCY(3),
         .SEPARATE_READ_WRITE_STALLS(0),
         .ASYNC_RESET(1),
         .SYNCHRONIZE_RESET(0)
      )
      s_endp
      (
         .clock(clock),
         .resetn(resetn),
         .m_intf(in_arb_intf),
         .s_intf(out_arb_intf),
         .s_readdatavalid(mout_rrp_datavalid),
         .s_readdata(mout_rrp_data),
         .s_writeack(mout_wrp_ack),
         .wrp_intf(wrp_intf),
         .rrp_intf(rrp_intf)
      );

   end
   endgenerate

   generate
   begin:wrp
      assign m[0].wrp_intf.ack = s.wrp_intf.ack;
      assign m[0].wrp_intf.id = s.wrp_intf.id;
   end
   endgenerate

   generate
   begin:rrp
      assign m[0].rrp_intf.datavalid = s.rrp_intf.datavalid;
      assign m[0].rrp_intf.data = s.rrp_intf.data;
      assign m[0].rrp_intf.id = s.rrp_intf.id;
   end
   endgenerate

   generate
      for( __i = 0; __i < 2; __i = __i + 1 )
      begin:dp
         acl_arb_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) in_intf();
         acl_arb_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) out_intf();

         // INST dp of acl_arb_pipeline_reg
         acl_arb_pipeline_reg
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1),
            .ASYNC_RESET(1),
            .SYNCHRONIZE_RESET(0)
         )
         dp
         (
            .clock(clock),
            .resetn(resetn),
            .in_intf(in_intf),
            .out_intf(out_intf)
         );

      end

   endgenerate

   generate
      for( __i = 0; __i < 1; __i = __i + 1 )
      begin:sp
         acl_arb_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) in_intf();
         acl_arb_intf
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1)
         ) out_intf();

         // INST sp of acl_arb_staging_reg
         acl_arb_staging_reg
         #(
            .DATA_W(64),
            .BURSTCOUNT_W(1),
            .ADDRESS_W(61),
            .BYTEENA_W(8),
            .ID_W(1),
            .ASYNC_RESET(1),
            .SYNCHRONIZE_RESET(0)
         )
         sp
         (
            .clock(clock),
            .resetn(resetn),
            .in_intf(in_intf),
            .out_intf(out_intf)
         );

      end

   endgenerate

   assign mout_arb_request = dp[0].out_intf.req.request;
   assign mout_arb_enable = dp[0].out_intf.req.enable;
   assign mout_arb_read = dp[0].out_intf.req.read;
   assign mout_arb_write = dp[0].out_intf.req.write;
   assign mout_arb_burstcount = dp[0].out_intf.req.burstcount;
   assign mout_arb_address = dp[0].out_intf.req.address;
   assign mout_arb_writedata = dp[0].out_intf.req.writedata;
   assign mout_arb_byteenable = dp[0].out_intf.req.byteenable;
   assign mout_arb_id = dp[0].out_intf.req.id;
   assign dp[0].out_intf.stall = mout_arb_stall;
   assign dp[0].in_intf.req = sp[0].out_intf.req;
   assign sp[0].out_intf.stall = dp[0].in_intf.stall;
   assign sp[0].in_intf.req = s.out_arb_intf.req;
   assign s.out_arb_intf.stall = sp[0].in_intf.stall;
   assign s.in_arb_intf.req = dp[1].out_intf.req;
   assign dp[1].out_intf.stall = s.in_arb_intf.stall;
   assign dp[1].in_intf.req = m[0].arb_intf.req;
   assign m[0].arb_intf.stall = dp[1].in_intf.stall;
endmodule

